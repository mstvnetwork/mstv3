<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Global Synced YouTube Player</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #player-container {
      position: relative;
      width: 100%;
      max-width: 640px;
      aspect-ratio: 16 / 9;
    }

    #scrolling-banner {
      width: 100%;
      background-color: #0047ab;
      color: white;
      padding: 8px;
      box-sizing: border-box;
      overflow: hidden;
      text-align: center;
    }

    #marquee-text {
      white-space: nowrap;
      overflow: hidden;
      animation: marquee 15s linear infinite;
      font-weight: bold;
    }

    #next-video-countdown {
      font-size: 0.85em;
      margin-top: 4px;
      white-space: nowrap;
    }

    @keyframes marquee {
      from { transform: translateX(100%); }
      to { transform: translateX(-100%); }
    }

    #mute-button {
      margin: 12px;
      padding: 6px 14px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="scrolling-banner">
    <div id="marquee-text">Now Playing: Loading...</div>
    <div id="next-video-countdown">Next video in: --:--</div>
  </div>

  <div id="player-container">
    <div id="player"></div>
  </div>

  <button id="mute-button">Mute</button>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    let player;
    let videoUrls = [];
    let videoDurations = [];
    let startTimeUTC = 0;
    let currentVideoIndex = 0;
    let isMuted = false;

    const marquee = document.getElementById("marquee-text");
    const countdownDiv = document.getElementById("next-video-countdown");

    function fetchSyncData() {
      return fetch("sync-ch1.json")
        .then((res) => res.json())
        .then((data) => {
          startTimeUTC = new Date(data.start_time_utc).getTime();
          videoUrls = data.video_urls;
        });
    }

    async function getVideoDuration(videoId) {
      return new Promise((resolve) => {
        const temp = new YT.Player(document.createElement("div"), {
          videoId,
          events: {
            onReady: (event) => {
              const duration = event.target.getDuration();
              event.target.destroy();
              resolve(duration);
            },
            onError: () => resolve(null)
          }
        });
      });
    }

    async function preloadDurations() {
      for (let id of videoUrls) {
        const duration = await getVideoDuration(id);
        if (duration) {
          videoDurations.push(duration);
        } else {
          console.warn("Skipped non-embeddable video:", id);
        }
      }
    }

    function calculateCurrentVideo() {
      const now = Date.now();
      const loopDuration = videoDurations.reduce((a, b) => a + b, 0) * 1000;
      const timeSinceStart = (now - startTimeUTC + loopDuration) % loopDuration;

      let elapsed = 0;
      for (let i = 0; i < videoDurations.length; i++) {
        const durationMs = videoDurations[i] * 1000;
        if (elapsed + durationMs > timeSinceStart) {
          return {
            index: i,
            seekTime: (timeSinceStart - elapsed) / 1000,
          };
        }
        elapsed += durationMs;
      }
      return { index: 0, seekTime: 0 };
    }

    function updateCountdown() {
      if (!videoDurations.length || !startTimeUTC) return;

      const now = Date.now();
      let totalMs = 0;
      let nextStartTime = null;

      for (let i = 0; i < videoDurations.length; i++) {
        const slotStart = startTimeUTC + totalMs;
        if (now < slotStart) {
          nextStartTime = slotStart;
          break;
        }
        totalMs += videoDurations[i] * 1000;
      }

      if (!nextStartTime) {
        const loopMs = videoDurations.reduce((a, b) => a + b, 0) * 1000;
        nextStartTime = startTimeUTC + loopMs;
        while (nextStartTime < now) {
          nextStartTime += loopMs;
        }
      }

      const secondsLeft = Math.floor((nextStartTime - now) / 1000);
      const mins = String(Math.floor(secondsLeft / 60)).padStart(2, "0");
      const secs = String(secondsLeft % 60).padStart(2, "0");

      countdownDiv.textContent = `Next video in: ${mins}:${secs}`;
    }

    function playCurrentVideo() {
      const { index, seekTime } = calculateCurrentVideo();
      currentVideoIndex = index;
      const videoId = videoUrls[index];

      marquee.textContent = "Now Playing: https://youtu.be/" + videoId;

      player.loadVideoById({
        videoId,
        startSeconds: seekTime,
      });
    }

    function onPlayerReady() {
      playCurrentVideo();
      setInterval(updateCountdown, 1000);
    }

    function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.ENDED) {
        currentVideoIndex = (currentVideoIndex + 1) % videoUrls.length;
        marquee.textContent = "Now Playing: https://youtu.be/" + videoUrls[currentVideoIndex];
        player.loadVideoById(videoUrls[currentVideoIndex]);
      }
    }

    async function syncAndPlay() {
      await fetchSyncData();
      await preloadDurations();

      const container = document.getElementById("player");
      player = new YT.Player(container, {
        height: "100%",
        width: "100%",
        videoId: videoUrls[0],
        events: {
          onReady: onPlayerReady,
          onStateChange: onPlayerStateChange,
        },
        playerVars: {
          autoplay: 1,
          controls: 1,
          mute: 0,
          rel: 0,
          modestbranding: 1,
        },
      });
    }

    function onYouTubeIframeAPIReady() {
      syncAndPlay();
    }

    document.getElementById("mute-button").onclick = () => {
      if (!player) return;
      isMuted = !isMuted;
      player[isMuted ? "mute" : "unMute"]();
      document.getElementById("mute-button").textContent = isMuted ? "Unmute" : "Mute";
    };
  </script>
</body>
</html>
