<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Live TV Channel</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1a1a1a; /* Dark background */
            color: #f0f0f0; /* Light text */
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .tv-container {
            width: 90%; /* Adjust as needed */
            max-width: 1280px; /* Max width for large screens, e.g., 720p or 1080p aspect */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #2a2a2a;
            margin-bottom: 20px; /* Space between TV and bottom content */
        }

        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 aspect ratio (height / width * 100) */
            height: 0;
            overflow: hidden;
            background-color: black; /* Background for when video is loading */
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; /* Place it above the video */
            pointer-events: auto; /* It will receive pointer events */
            /* background: rgba(255, 0, 0, 0.1); /* Uncomment for debugging to see the overlay */
        }

        /* Custom Unmute Button */
        .unmute-button {
            position: absolute;
            bottom: 20px; /* Adjust position from bottom */
            right: 20px; /* Adjust position from right */
            z-index: 20; /* Place it above the overlay */
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        .unmute-button:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .unmute-button .mute-icon { display: none; }
        .unmute-button.muted .mute-icon { display: inline-block; }
        .unmute-button.muted .unmute-icon { display: none; }
        .unmute-button:not(.muted) .mute-icon { display: none; }
        .unmute-button:not(.muted) .unmute-icon { display: inline-block; }

        /* Program Guide */
        .program-guide-container {
            padding: 20px;
            background-color: #222;
            border-top: 1px solid #333;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        .program-guide-container h3, .program-guide-container h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #fff;
            text-align: center;
        }

        #nowPlayingTitle {
            color: #4CAF50; /* Highlight current program */
        }

        #upcomingList {
            list-style: none;
            padding: 0;
            margin: 10px 0 0 0;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap */
            justify-content: center;
            gap: 10px; /* Space between list items */
        }

        #upcomingList li {
            padding: 8px 12px;
            font-size: 0.9em;
            color: #bbb;
            background-color: #333;
            border-radius: 5px;
            flex-grow: 1; /* Allow items to grow to fill space */
            text-align: center;
            max-width: 300px; /* Limit width for longer titles */
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .tv-container {
                width: 95%;
            }

            .unmute-button {
                bottom: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 1.2em;
            }

            .program-guide-container {
                padding: 15px;
            }

            #upcomingList li {
                font-size: 0.85em;
                padding: 6px 10px;
            }
        }

        @media (max-width: 480px) {
            .tv-container {
                width: 100%;
                border-radius: 0;
            }
            .unmute-button {
                bottom: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 1em;
            }
            .program-guide-container {
                padding: 10px;
            }
            #upcomingList {
                flex-direction: column; /* Stack upcoming programs on small screens */
                align-items: center;
            }
        }
    </style>
</head>
<body>

    <div class="tv-container">
        <div class="video-container">
            <div id="player"></div>
            <div class="video-overlay"></div> <button id="unmuteButton" class="unmute-button muted">
                <span class="mute-icon">ðŸ”‡</span>
                <span class="unmute-icon">ðŸ”Š</span>
            </button>
        </div>

        <div class="program-guide-container">
            <h3>Now Playing: <span id="nowPlayingTitle">Loading...</span></h3>
            <div id="upcomingPrograms">
                <h4>Upcoming:</h4>
                <ul id="upcomingList">
                    <li>Loading upcoming programs...</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Define your YouTube playlist with video IDs and titles
        // IMPORTANT: Replace 'VIDEO_ID_...' with your actual YouTube video IDs
        const youtubePlaylist = [
            { id: '17LL_iqlHE8', title: 'Never Gonna Give You Up' }, // Example: Rick Astley
            { id: 'M7lc1UVf-VE', title: 'Lofi Hip Hop Radio' },      // Example: Lofi Girl
            { id: 'LXb3EKWsInQ', title: 'Epic Nature Documentary' }, // Example: Nature clip
            { id: 'k-LgJ52aU5Y', title: 'Cozy Fireplace Sounds' },   // Example: Fireplace
            { id: 'VIDEO_ID_5', title: 'Your Fifth Video Title' },
            // Add more video objects here { id: 'YOUR_VIDEO_ID', title: 'Your Video Title' }
        ];

        const LAST_PLAYED_KEY = 'lastPlayedVideo'; // Key for localStorage
        let currentVideoIndex = 0;
        let player; // Holds the YouTube player object
        let saveInterval; // To clear the interval on unload

        const unmuteButton = document.getElementById('unmuteButton');
        const nowPlayingTitleElement = document.getElementById('nowPlayingTitle');
        const upcomingListElement = document.getElementById('upcomingList');

        // This function creates an <iframe> (and YouTube player)
        // after the API code downloads.
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '390', // Default height (will be overridden by CSS)
                width: '640',  // Default width (will be overridden by CSS)
                videoId: youtubePlaylist[currentVideoIndex].id,
                playerVars: {
                    'autoplay': 1,      // Autoplay the video (will be muted due to browser policy)
                    'controls': 0,      // Hide all default controls (seek bar, timestamp, etc.)
                    'disablekb': 1,     // Disable keyboard controls
                    'autohide': 1,      // Hide controls when idle (though they are already hidden)
                    'modestbranding': 1, // Remove YouTube logo on control bar
                    'rel': 0,           // Do not show related videos at the end
                    'iv_load_policy': 3 // Do not show video annotations
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError // Add error handling
                }
            });
        }

        // The API will call this function when the video player is ready.
        function onPlayerReady(event) {
            // Attempt to load previous state from localStorage
            const lastPlayed = JSON.parse(localStorage.getItem(LAST_PLAYED_KEY));
            if (lastPlayed && youtubePlaylist[lastPlayed.index]) {
                currentVideoIndex = lastPlayed.index;
                // Load video by ID and start at the saved time
                player.loadVideoById(youtubePlaylist[currentVideoIndex].id, lastPlayed.time);
            } else {
                // If no saved state, start with the first video from the beginning
                event.target.playVideo();
            }

            // Mute the player initially to comply with autoplay policies
            player.mute();
            unmuteButton.classList.add('muted'); // Ensure button reflects muted state

            // Start periodically saving current time to localStorage
            saveInterval = setInterval(() => {
                if (player && player.getCurrentTime) {
                    localStorage.setItem(LAST_PLAYED_KEY, JSON.stringify({
                        index: currentVideoIndex,
                        time: player.getCurrentTime()
                    }));
                }
            }, 5000); // Save every 5 seconds

            // Update the program guide when the player is ready
            updateProgramGuide();
        }

        // The API calls this function when the player's state changes.
        function onPlayerStateChange(event) {
            // If the video has ended, play the next one in the playlist
            if (event.data === YT.PlayerState.ENDED) {
                currentVideoIndex++;
                if (currentVideoIndex >= youtubePlaylist.length) {
                    currentVideoIndex = 0; // Loop back to the beginning
                }
                player.loadVideoById(youtubePlaylist[currentVideoIndex].id);
                updateProgramGuide(); // Update guide after video changes
            }
        }

        // Handle player errors (e.g., video not found, private video)
        function onPlayerError(event) {
            console.error('YouTube Player Error:', event.data);
            // Attempt to skip to the next video
            currentVideoIndex++;
            if (currentVideoIndex >= youtubePlaylist.length) {
                currentVideoIndex = 0; // Loop back
            }
            player.loadVideoById(youtubePlaylist[currentVideoIndex].id);
            updateProgramGuide();
        }

        // Unmute button functionality
        unmuteButton.addEventListener('click', () => {
            if (player.isMuted()) {
                player.unMute();
                unmuteButton.classList.remove('muted');
            } else {
                player.mute();
                unmuteButton.classList.add('muted');
            }
        });

        // Function to update the program guide display
        function updateProgramGuide() {
            // Update "Now Playing" title
            nowPlayingTitleElement.textContent = youtubePlaylist[currentVideoIndex].title;

            // Update "Upcoming" list
            upcomingListElement.innerHTML = ''; // Clear previous list
            const numUpcoming = 3; // Show the next 3 programs
            for (let i = 1; i <= numUpcoming; i++) {
                const nextIndex = (currentVideoIndex + i) % youtubePlaylist.length;
                const listItem = document.createElement('li');
                listItem.textContent = youtubePlaylist[nextIndex].title;
                upcomingListElement.appendChild(listItem);
            }
        }

        // Load the IFrame Player API asynchronously.
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // Clear the save interval when the page is about to be unloaded
        // This helps prevent potential memory leaks or errors in some browser scenarios
        window.addEventListener('beforeunload', () => {
            clearInterval(saveInterval);
        });
    </script>

</body>
</html>
