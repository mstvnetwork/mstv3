<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV Channel</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate-900 */
            color: #e2e8f0; /* Slate-200 */
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            height: 0;
            overflow: hidden;
            background-color: #000;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .video-container iframe,
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.75rem;
        }
        /* Hide scrollbar for a cleaner look */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold text-blue-400 mb-2">Live TV Channel</h1>
        <p class="text-lg text-slate-300">Broadcasting content from your GitHub playlist</p>
    </header>

    <main class="flex flex-col lg:flex-row flex-grow gap-6">
        <!-- Video Player Section -->
        <section class="lg:w-3/4 flex-grow bg-slate-800 p-4 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 text-blue-300">Now Playing</h2>
            <div class="video-container mb-4">
                <div id="player"></div>
            </div>
            <div class="text-xl font-medium text-slate-100" id="current-channel-info">
                Loading channel...
            </div>
        </section>

        <!-- Playlist & Controls Section -->
        <aside class="lg:w-1/4 bg-slate-800 p-4 rounded-xl shadow-lg flex flex-col">
            <h2 class="text-2xl font-semibold mb-4 text-blue-300">Channels</h2>
            <div id="channel-list" class="flex-grow overflow-y-auto no-scrollbar pr-2 mb-4">
                <!-- Channels will be loaded here by JavaScript -->
                <p class="text-slate-400">Loading channels...</p>
            </div>

            <div class="mt-auto pt-4 border-t border-slate-700">
                <h3 class="text-xl font-semibold mb-2 text-blue-300">Controls</h3>
                <div class="flex items-center justify-between mb-2">
                    <span class="text-slate-300">Broadcast Time:</span>
                    <span id="broadcast-time" class="font-bold text-lg text-green-400">00:00:00</span>
                </div>
                <div class="flex items-center justify-between">
                    <button id="restart-broadcast" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                        <svg class="w-5 h-5 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12m7-7h.582m-6.782 5H4m6.782 5H4m6.782-5h.582m-6.782 5H4"></path></svg>
                        Restart Broadcast
                    </button>
                    <button id="toggle-manual-sync" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 ml-2">
                         <svg class="w-5 h-5 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        Manual Channel Sync
                    </button>
                </div>
            </div>
        </aside>
    </main>

    <!-- Modal for messages -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-slate-700 p-6 rounded-xl shadow-xl max-w-sm w-full text-center">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-blue-300"></h3>
            <p id="modal-message" class="text-slate-200 mb-6"></p>
            <button id="modal-close" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Close</button>
        </div>
    </div>


    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // Use a default appId if not provided by the environment (e.g., when running locally)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-live-tv-app';

        // Firebase configuration (parsed from global variable)
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        let db;
        let auth;
        let userId = 'anonymous'; // Default to anonymous

        // Initialize Firebase and authenticate
        async function initializeFirebase() {
            if (firebaseConfig) {
                // Dynamically import Firebase modules
                const { initializeApp } = await import("https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js");
                const { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js");
                const { getFirestore, doc, setDoc, onSnapshot, collection } = await import("https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js");

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in with custom token if available, otherwise anonymously
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } catch (error) {
                        console.error("Error signing in with custom token:", error);
                        await signInAnonymously(auth); // Fallback to anonymous if custom token fails
                    }
                } else {
                    await signInAnonymously(auth);
                }

                // Listen for auth state changes to get the user ID
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User ID:", userId);
                        // Start syncing broadcast time after authentication
                        setupBroadcastTimeSync();
                    } else {
                        console.log("No user signed in.");
                        // If no user, still try to setup, but persistence might not work
                        setupBroadcastTimeSync();
                    }
                });
            } else {
                console.warn("Firebase configuration not found. Running without Firestore persistence.");
                setupBroadcastTimeSync(); // Run without persistence
            }
        }

        // Call Firebase initialization
        initializeFirebase();

        // --- Global Variables ---
        const GITHUB_PLAYLIST_URL = 'https://raw.githubusercontent.com/AniruddhaVaidya/playlist/main/playlist.json'; // IMPORTANT: Replace with your actual GitHub raw playlist.json URL
        let playlist = [];
        let youtubePlayer;
        let hlsPlayer;
        let currentChannel = null;
        let isPlayerReady = false;
        let totalVodDuration = 0; // Total duration of all VODs in seconds
        let broadcastStartTime = Date.now(); // Epoch time when the broadcast conceptually started
        let currentBroadcastPosition = 0; // Current position in the overall broadcast cycle (in seconds)
        let broadcastInterval; // Interval for broadcast time updates
        let manualChannelSync = false; // Flag to enable/disable automatic time sync

        // --- DOM Elements ---
        const playerContainer = document.getElementById('player');
        const channelListDiv = document.getElementById('channel-list');
        const currentChannelInfoDiv = document.getElementById('current-channel-info');
        const broadcastTimeSpan = document.getElementById('broadcast-time');
        const restartBroadcastButton = document.getElementById('restart-broadcast');
        const toggleManualSyncButton = document.getElementById('toggle-manual-sync');
        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseButton = document.getElementById('modal-close');

        // --- Utility Functions ---

        /**
         * Displays a message modal to the user.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message content.
         */
        function showMessage(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
        }

        /**
         * Closes the message modal.
         */
        modalCloseButton.onclick = () => {
            messageModal.classList.add('hidden');
        };

        /**
         * Formats seconds into HH:MM:SS.
         * @param {number} totalSeconds - The total number of seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return [hours, minutes, seconds]
                .map(unit => unit < 10 ? '0' + unit : unit)
                .join(':');
        }

        /**
         * Fetches the playlist.json from the GitHub repository.
         */
        async function fetchPlaylist() {
            try {
                const response = await fetch(GITHUB_PLAYLIST_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                playlist = data;
                console.log("Playlist fetched:", playlist);
                calculateTotalVodDuration();
                renderChannelList();
                // Start the broadcast after playlist is loaded and player is ready
                if (isPlayerReady) {
                    startBroadcast();
                }
            } catch (error) {
                console.error("Error fetching playlist:", error);
                showMessage("Error", "Failed to load playlist. Please check the GitHub URL and your internet connection. " + error.message);
                channelListDiv.innerHTML = '<p class="text-red-400">Failed to load channels.</p>';
            }
        }

        /**
         * Calculates the total duration of all VOD items in the playlist.
         */
        function calculateTotalVodDuration() {
            totalVodDuration = 0;
            playlist.forEach(channel => {
                if (channel.type === 'youtube_vod' && channel.duration) {
                    totalVodDuration += channel.duration;
                }
            });
            console.log("Total VOD duration:", totalVodDuration, "seconds");
        }

        /**
         * Renders the list of channels on the webpage.
         */
        function renderChannelList() {
            channelListDiv.innerHTML = ''; // Clear previous list
            if (playlist.length === 0) {
                channelListDiv.innerHTML = '<p class="text-slate-400">No channels found in playlist.</p>';
                return;
            }

            playlist.forEach(channel => {
                const button = document.createElement('button');
                button.className = 'w-full text-left py-2 px-3 mb-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors duration-200 text-slate-100 font-medium shadow-md';
                button.textContent = channel.name;
                button.onclick = () => switchChannelManual(channel.id);
                channelListDiv.appendChild(button);
            });
        }

        /**
         * Switches to a specific channel manually.
         * @param {string} channelId - The ID of the channel to switch to.
         */
        function switchChannelManual(channelId) {
            manualChannelSync = true; // Disable automatic sync
            toggleManualSyncButton.textContent = 'Enable Auto Sync';
            toggleManualSyncButton.classList.remove('bg-blue-600');
            toggleManualSyncButton.classList.add('bg-orange-600');

            const selectedChannel = playlist.find(c => c.id === channelId);
            if (selectedChannel) {
                console.log("Manually switching to channel:", selectedChannel.name);
                playChannel(selectedChannel);
            } else {
                console.warn("Channel not found:", channelId);
                showMessage("Channel Error", `Channel with ID "${channelId}" not found.`);
            }
        }

        /**
         * Manages playing a given channel.
         * @param {Object} channel - The channel object to play.
         * @param {number} [seekTime=0] - The time in seconds to seek to (for VODs).
         */
        function playChannel(channel, seekTime = 0) {
            if (!isPlayerReady) {
                console.warn("Player not ready, cannot play channel.");
                return;
            }

            if (currentChannel && currentChannel.id === channel.id && !manualChannelSync) {
                // If it's the same channel and not manual sync, we might just need to seek if VOD
                if (channel.type === 'youtube_vod' && youtubePlayer && youtubePlayer.getPlayerState() !== 1 /* Playing */) {
                    youtubePlayer.seekTo(seekTime, true);
                    youtubePlayer.playVideo();
                } else if (channel.type === 'm3u8' && hlsPlayer && hlsPlayer.media) {
                    // For M3U8, just ensure it's playing
                    hlsPlayer.media.play();
                }
                return; // Already playing this channel, no need to re-initialize
            }

            currentChannel = channel;
            currentChannelInfoDiv.textContent = `Channel: ${channel.name}`;
            console.log(`Playing channel: ${channel.name} (Type: ${channel.type})`);

            // Clear previous player
            playerContainer.innerHTML = '';
            if (youtubePlayer) {
                youtubePlayer.destroy();
                youtubePlayer = null;
            }
            if (hlsPlayer) {
                hlsPlayer.destroy();
                hlsPlayer = null;
            }

            if (channel.type === 'youtube_live' || channel.type === 'youtube_vod') {
                const videoId = getYouTubeVideoId(channel.url);
                if (videoId) {
                    playerContainer.innerHTML = '<div id="youtube-iframe"></div>';
                    youtubePlayer = new YT.Player('youtube-iframe', {
                        videoId: videoId,
                        playerVars: {
                            'autoplay': 1,
                            'controls': 1,
                            'rel': 0, // Disable related videos
                            'modestbranding': 1, // Minimal YouTube branding
                            'loop': 0,
                            'disablekb': 1 // Disable keyboard controls
                        },
                        events: {
                            'onReady': (event) => {
                                if (channel.type === 'youtube_vod') {
                                    event.target.seekTo(seekTime, true);
                                }
                                event.target.playVideo();
                            },
                            'onError': (event) => {
                                console.error('YouTube Player Error:', event.data);
                                showMessage("YouTube Error", `Could not load YouTube video for "${channel.name}". Error code: ${event.data}`);
                            }
                        }
                    });
                } else {
                    showMessage("Invalid YouTube URL", `Could not extract video ID from URL: ${channel.url}`);
                }
            } else if (channel.type === 'm3u8') {
                const videoElement = document.createElement('video');
                videoElement.controls = true;
                videoElement.autoplay = true;
                videoElement.className = 'w-full h-full';
                playerContainer.appendChild(videoElement);

                if (Hls.isSupported()) {
                    hlsPlayer = new Hls();
                    hlsPlayer.loadSource(channel.url);
                    hlsPlayer.attachMedia(videoElement);
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('HLS manifest parsed. Playing...');
                        videoElement.play().catch(e => console.error("Video play failed:", e));
                    });
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS.js error:', data);
                        if (data.fatal) {
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    showMessage("Network Error", `Network error during HLS stream for "${channel.name}". Retrying...`);
                                    hlsPlayer.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    showMessage("Media Error", `Media error during HLS stream for "${channel.name}". Attempting recovery...`);
                                    hlsPlayer.recoverMediaError();
                                    break;
                                default:
                                    showMessage("Fatal HLS Error", `A fatal error occurred with the HLS stream for "${channel.name}". Please try again.`);
                                    break;
                            }
                        }
                    });
                } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                    videoElement.src = channel.url;
                    videoElement.addEventListener('loadedmetadata', () => {
                        videoElement.play().catch(e => console.error("Video play failed:", e));
                    });
                } else {
                    showMessage("Browser Not Supported", "Your browser does not support HLS streaming directly or via hls.js.");
                }
            } else {
                showMessage("Unsupported Type", `Channel type "${channel.type}" is not supported.`);
            }
        }

        /**
         * Extracts YouTube video ID from various YouTube URL formats.
         * @param {string} url - The YouTube video URL.
         * @returns {string|null} The video ID or null if not found.
         */
        function getYouTubeVideoId(url) {
            const regExp = /(?:youtube\.com\/(?:[^\/]+\/.+\/|\/(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i;
            const match = url.match(regExp);
            return (match && match[1]) ? match[1] : null;
        }

        // --- YouTube IFrame API Ready Callback ---
        function onYouTubeIframeAPIReady() {
            isPlayerReady = true;
            console.log("YouTube IFrame API is ready.");
            if (playlist.length > 0) {
                startBroadcast();
            }
        }
        window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady; // Make available globally

        /**
         * Determines the current broadcast channel and play position based on time.
         */
        function updateBroadcastChannel() {
            if (manualChannelSync || !totalVodDuration) {
                return; // Do nothing if manual sync is active or no VODs
            }

            const currentTime = Date.now();
            const elapsedMillis = currentTime - broadcastStartTime;
            let relativeElapsedSeconds = (elapsedMillis / 1000) % totalVodDuration;

            let cumulativeDuration = 0;
            let foundChannel = null;
            let foundSeekTime = 0;

            for (const channel of playlist) {
                if (channel.type === 'youtube_vod' && channel.duration) {
                    if (relativeElapsedSeconds >= cumulativeDuration && relativeElapsedSeconds < cumulativeDuration + channel.duration) {
                        foundChannel = channel;
                        foundSeekTime = relativeElapsedSeconds - cumulativeDuration;
                        break;
                    }
                    cumulativeDuration += channel.duration;
                } else if (channel.type === 'youtube_live' || channel.type === 'm3u8') {
                    // For live channels, play them if their turn comes up in the sequence
                    // This is a simplification; a true live channel wouldn't fit into a cyclical VOD schedule easily.
                    // For this implementation, live channels will be treated as very short "placeholders" in the VOD cycle
                    // or will be selected explicitly by the user or as the 'default' if no VODs.
                    // To truly incorporate live streams into a linear TV schedule requires a more complex scheduler.
                    // For now, if currentChannel is a live stream, it keeps playing unless overridden.
                    // Or, if the playlist has ONLY live streams, we just pick the first one.
                    // Let's refine: If it's a VOD cycle, live streams are outside this auto-sync.
                    // The auto-sync primarily governs VOD cycling.
                    // For simplicity, if a channel is "live", it implies it's continuously on.
                    // The time sync logic here will primarily focus on cycling through VODs.
                }
            }

            // If no VOD channels, or if elapsed time is outside the known VOD cycle,
            // we could default to the first live channel, or simply do nothing until a VOD's time comes.
            if (!foundChannel && playlist.length > 0) {
                // If VODs exist, but we haven't found a match within the current cycle
                // this means the current time modulo totalVodDuration landed somewhere it shouldn't.
                // This shouldn't happen if totalVodDuration is correctly calculated.
                // If playlist has no VODs but has live channels, always play the first live channel.
                 const firstLiveChannel = playlist.find(c => c.type === 'youtube_live' || c.type === 'm3u8');
                 if (firstLiveChannel && (!currentChannel || currentChannel.id !== firstLiveChannel.id)) {
                     playChannel(firstLiveChannel);
                 } else if (!currentChannel && playlist.length > 0) {
                     // If no VODs and no live, just play the first channel.
                     playChannel(playlist[0]);
                 }
                return;
            }


            if (foundChannel && (!currentChannel || currentChannel.id !== foundChannel.id || !manualChannelSync)) {
                // Only switch if it's a new channel or we're in auto-sync and it's time to switch
                console.log(`Auto-switching to: ${foundChannel.name} at ${formatTime(foundSeekTime)}`);
                playChannel(foundChannel, foundSeekTime);
            } else if (foundChannel && currentChannel.id === foundChannel.id && foundChannel.type === 'youtube_vod' && youtubePlayer && youtubePlayer.getPlayerState() !== 1 /* Playing */) {
                // If it's the same VOD channel but paused/buffering, ensure it's playing and correctly seeks
                youtubePlayer.seekTo(foundSeekTime, true);
                youtubePlayer.playVideo();
            }

            // Update display of broadcast time
            currentBroadcastPosition = relativeElapsedSeconds;
            broadcastTimeSpan.textContent = formatTime(currentBroadcastPosition);
        }

        /**
         * Starts the broadcast logic (fetching playlist, setting up intervals).
         */
        function startBroadcast() {
            if (!playlist || playlist.length === 0) {
                // console.warn("Playlist not loaded or empty, cannot start broadcast.");
                return;
            }
            clearInterval(broadcastInterval); // Clear any existing interval

            // If Firebase is configured and user is authenticated, load broadcast time from Firestore
            if (db && userId) {
                 const docRef = doc(db, `artifacts/${appId}/users/${userId}/settings`, "broadcast_state");
                 onSnapshot(docRef, (docSnap) => {
                     if (docSnap.exists()) {
                         const data = docSnap.data();
                         broadcastStartTime = data.broadcastStartTime || Date.now();
                         console.log("Loaded broadcastStartTime from Firestore:", new Date(broadcastStartTime).toLocaleString());
                     } else {
                         console.log("No broadcast state in Firestore, initializing with current time.");
                         broadcastStartTime = Date.now(); // Initialize if not found
                         saveBroadcastState(); // Save initial state
                     }
                     // After loading/initializing, start the interval
                     broadcastInterval = setInterval(updateBroadcastChannel, 1000); // Update every second
                     updateBroadcastChannel(); // Initial update
                 }, (error) => {
                     console.error("Error fetching broadcast state from Firestore:", error);
                     // Fallback to local time if Firestore fails
                     broadcastStartTime = Date.now();
                     broadcastInterval = setInterval(updateBroadcastChannel, 1000);
                     updateBroadcastChannel();
                 });
            } else {
                // If Firebase not configured or not authenticated, use local time
                console.log("Using local time for broadcast sync (Firebase not active).");
                broadcastStartTime = Date.now();
                broadcastInterval = setInterval(updateBroadcastChannel, 1000); // Update every second
                updateBroadcastChannel(); // Initial update
            }
        }

        /**
         * Saves the current broadcast state to Firestore.
         */
        async function saveBroadcastState() {
            if (db && userId) {
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/settings`, "broadcast_state");
                    await setDoc(docRef, {
                        broadcastStartTime: broadcastStartTime,
                        lastUpdated: Date.now()
                    }, { merge: true });
                    console.log("Broadcast state saved to Firestore.");
                } catch (error) {
                    console.error("Error saving broadcast state to Firestore:", error);
                }
            }
        }

        /**
         * Sets up the broadcast time synchronization using Firestore.
         * Called after Firebase initialization.
         */
        function setupBroadcastTimeSync() {
            // Fetch playlist first, then start broadcast
            fetchPlaylist();
        }

        // --- Event Listeners ---
        restartBroadcastButton.onclick = () => {
            broadcastStartTime = Date.now();
            saveBroadcastState(); // Persist the new start time
            manualChannelSync = false; // Reset manual sync
            toggleManualSyncButton.textContent = 'Manual Channel Sync';
            toggleManualSyncButton.classList.remove('bg-orange-600');
            toggleManualSyncButton.classList.add('bg-blue-600');
            updateBroadcastChannel(); // Immediately update to new time
            showMessage("Broadcast Restarted", "The broadcast has been reset to the current time.");
        };

        toggleManualSyncButton.onclick = () => {
            manualChannelSync = !manualChannelSync;
            if (manualChannelSync) {
                toggleManualSyncButton.textContent = 'Enable Auto Sync';
                toggleManualSyncButton.classList.remove('bg-blue-600');
                toggleManualSyncButton.classList.add('bg-orange-600');
                showMessage("Manual Sync Enabled", "Automatic channel switching is now paused. Click on a channel to play it.");
            } else {
                toggleManualSyncButton.textContent = 'Manual Channel Sync';
                toggleManualSyncButton.classList.remove('bg-orange-600');
                toggleManualSyncButton.classList.add('bg-blue-600');
                updateBroadcastChannel(); // Trigger update immediately to re-sync
                showMessage("Auto Sync Enabled", "Automatic channel switching is now active, following the broadcast schedule.");
            }
            console.log("Manual Channel Sync:", manualChannelSync);
        };

        // --- Initial Load ---
        // The fetchPlaylist is now called within initializeFirebase to ensure Firebase is ready.
        // onYouTubeIframeAPIReady will call startBroadcast when player is ready.

    </script>
</body>
</html>
