<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MSTV Network - Looping Playlist Player</title>
<style>
  body { background: #000; color: #fff; font-family: Arial, sans-serif; text-align: center; margin: 0; }
  #player-container { position: relative; width: 100vw; max-width: 960px; aspect-ratio: 16/9; margin: 20px auto; background: #222; border: 3px solid gold; border-radius: 12px; overflow: hidden; }
  video, iframe { width: 100%; height: 100%; background: black; }
  #placeholder-image { display: flex; align-items: center; justify-content: center; color: #999; font-size: 1.5rem; height: 100%; }
  #loading { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.8); color: #000; padding: 5px 10px; border-radius: 5px; display: none; font-weight: bold; }
  #unmute-button { position: absolute; bottom: 10px; right: 10px; background: rgba(255,255,255,0.8); color: #000; border: none; padding: 6px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; display: none; }
  #now-playing-container { max-width: 960px; margin: 0 auto 20px; font-size: 1.2rem; font-weight: bold; }
  /* Overlay for unmute prompt on iframe streams */
  #iframe-unmute-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: red;
    color: white;
    font-size: 1.8rem;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 10;
    user-select: none;
    display: none; /* hidden by default */
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>

<h1>MSTV Network - Looping Playlist</h1>

<div id="player-container">
  <video id="video-player" playsinline controls muted></video>
  <iframe id="media-player" frameborder="0" allowfullscreen allow="autoplay; fullscreen" style="display:none;"></iframe>
  <div id="placeholder-image">Loading stream...</div>
  <div id="loading">Loading...</div>
  <button id="unmute-button">üîá Unmute</button>
  <div id="iframe-unmute-overlay">Click to unmute ‚ñ∂Ô∏è</div>
</div>

<div id="now-playing-container">
  Now Playing: <span id="current-channel-name">None</span> |
  Time Remaining: <span id="countdown-timer">--:--</span>
</div>

<script>
  const videoPlayer = document.getElementById('video-player');
  const iframePlayer = document.getElementById('media-player');
  const placeholder = document.getElementById('placeholder-image');
  const loading = document.getElementById('loading');
  const unmuteButton = document.getElementById('unmute-button');
  const currentChannelName = document.getElementById('current-channel-name');
  const countdownTimer = document.getElementById('countdown-timer');
  const iframeUnmuteOverlay = document.getElementById('iframe-unmute-overlay');

  const githubJsonUrl = 'https://raw.githubusercontent.com/mstvnetwork/mstv3/refs/heads/main/channels.json';

  let hlsInstance = null;
  let playlist = [];
  let currentIndex = -1;
  let countdownInterval = null;

  const slotDurationSeconds = 120; // 2 minutes per slot

  function showLoading(show) {
    loading.style.display = show ? 'block' : 'none';
  }

  function updateUnmuteButton() {
    if (videoPlayer.muted) {
      unmuteButton.style.display = 'block';
    } else {
      unmuteButton.style.display = 'none';
    }
  }

  unmuteButton.addEventListener('click', () => {
    videoPlayer.muted = false;
    updateUnmuteButton();
  });

  videoPlayer.addEventListener('volumechange', updateUnmuteButton);

  function clearPlayers() {
    if (hlsInstance) {
      hlsInstance.destroy();
      hlsInstance = null;
    }
    videoPlayer.pause();
    videoPlayer.removeAttribute('src');
    videoPlayer.load();
    iframePlayer.src = '';
    videoPlayer.style.display = 'none';
    iframePlayer.style.display = 'none';
    placeholder.style.display = 'none';
    unmuteButton.style.display = 'none';
    iframeUnmuteOverlay.style.display = 'none';
    showLoading(false);
    currentChannelName.textContent = 'None';
    countdownTimer.textContent = '--:--';
    if (countdownInterval) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
  }

  function playChannel(channel, remainingSeconds) {
    clearPlayers();
    showLoading(true);

    currentChannelName.textContent = channel.name;

    if (channel.type === 'hls') {
      iframeUnmuteOverlay.style.display = 'none'; // no overlay on HLS
      if (Hls.isSupported()) {
        videoPlayer.style.display = 'block';
        hlsInstance = new Hls();
        hlsInstance.loadSource(channel.url);
        hlsInstance.attachMedia(videoPlayer);
        hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
          videoPlayer.muted = true;
          videoPlayer.play().then(() => {
            showLoading(false);
            updateUnmuteButton();
            startCountdown(remainingSeconds);
          });
        });
        hlsInstance.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            hlsInstance.destroy();
            clearPlayers();
            placeholder.textContent = 'Stream error occurred.';
            placeholder.style.display = 'flex';
          }
        });
      } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
        videoPlayer.style.display = 'block';
        videoPlayer.src = channel.url;
        videoPlayer.muted = true;
        videoPlayer.play().then(() => {
          showLoading(false);
          updateUnmuteButton();
          startCountdown(remainingSeconds);
        });
      } else {
        placeholder.textContent = 'Your browser does not support HLS.';
        placeholder.style.display = 'flex';
        showLoading(false);
      }
    } else if (channel.type === 'iframe') {
      iframePlayer.style.display = 'block';
      // Remove mute=1 param if present, add autoplay=1 if missing
      let url = new URL(channel.url);
      url.searchParams.delete('mute');
      url.searchParams.set('autoplay', '1');

      iframePlayer.src = url.toString();
      showLoading(true);

      // Show the unmute overlay for iframe streams
      iframeUnmuteOverlay.style.display = 'flex';

      iframePlayer.onload = () => {
        showLoading(false);
        startCountdown(remainingSeconds);
      };
      iframePlayer.onerror = () => {
        clearPlayers();
        placeholder.textContent = 'Failed to load iframe stream.';
        placeholder.style.display = 'flex';
      };
    } else {
      iframeUnmuteOverlay.style.display = 'none';
      videoPlayer.style.display = 'block';
      videoPlayer.src = channel.url;
      videoPlayer.muted = true;
      videoPlayer.play().then(() => {
        showLoading(false);
        updateUnmuteButton();
        startCountdown(remainingSeconds);
      }).catch(() => {
        placeholder.textContent = 'Playback failed for this video.';
        placeholder.style.display = 'flex';
        showLoading(false);
      });
    }
  }

  // When user clicks the overlay, hide it and reload iframe with autoplay and no mute param
  iframeUnmuteOverlay.addEventListener('click', () => {
    iframeUnmuteOverlay.style.display = 'none';
    if (currentIndex >= 0 && playlist[currentIndex] && playlist[currentIndex].type === 'iframe') {
      let channel = playlist[currentIndex];
      // Reload iframe with mute param removed and autoplay=1 explicitly
      let url = new URL(channel.url);
      url.searchParams.delete('mute');
      url.searchParams.set('autoplay', '1');
      iframePlayer.src = url.toString();
    }
  });

  function startCountdown(seconds) {
    if (countdownInterval) clearInterval(countdownInterval);
    let remaining = seconds;
    function updateCountdown() {
      const minutes = Math.floor(remaining / 60).toString().padStart(2, '0');
      const secs = (remaining % 60).toString().padStart(2, '0');
      countdownTimer.textContent = `${minutes}:${secs}`;
      if (remaining <= 0) {
        clearInterval(countdownInterval);
      }
      remaining--;
    }
    updateCountdown();
    countdownInterval = setInterval(() => {
      updateCountdown();
    }, 1000);
  }

  function getChannelIndexByTime() {
    const now = new Date();
    const midnight = new Date(now);
    midnight.setHours(0, 0, 0, 0);
    const secondsSinceMidnight = Math.floor((now - midnight) / 1000);
    const totalSlots = playlist.length;
    const slotNumber = Math.floor(secondsSinceMidnight / slotDurationSeconds) % totalSlots;
    const secondsIntoSlot = secondsSinceMidnight % slotDurationSeconds;
    const remainingSeconds = slotDurationSeconds - secondsIntoSlot;
    return { slotNumber, remainingSeconds };
  }

  async function fetchPlaylistAndStart() {
    try {
      const urlWithCacheBuster = `${githubJsonUrl}?cacheBuster=${Date.now()}`;
      const response = await fetch(urlWithCacheBuster);
      if (!response.ok) throw new Error('Failed to fetch playlist JSON');
      const data = await response.json();

      if (!Array.isArray(data) || data.length === 0) {
        placeholder.textContent = 'Playlist is empty.';
        placeholder.style.display = 'flex';
        return;
      }

      playlist = data;

      updatePlayerByTime();

      setInterval(updatePlayerByTime, 1000);

    } catch (e) {
      console.error('Error fetching or playing playlist:', e);
      placeholder.textContent = 'Error loading streams.';
      placeholder.style.display = 'flex';
      showLoading(false);
    }
  }

  function updatePlayerByTime() {
    const { slotNumber, remainingSeconds } = getChannelIndexByTime();
    if (slotNumber !== currentIndex) {
      currentIndex = slotNumber;
      playChannel(playlist[slotNumber], remainingSeconds);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    fetchPlaylistAndStart();
  });
</script>

</body>
</html>
