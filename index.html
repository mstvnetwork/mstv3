<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
    <title>MSTV Live</title>
    <!-- Google Fonts for 'Inter' (used in TV guide for modern look), 'Segoe UI' (body), 'Consolas' (guide times) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            text-align: center;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensure footer stays at the bottom */
        }
        .title {
            font-size: 2.5rem;
            font-weight: 900;
            color: gold;
            margin: 1rem 0 0;
            text-shadow: 0 0 15px gold;
        }
        .golden-scroll {
            color: orange;
            font-weight: 700;
            margin-bottom: 1rem;
            user-select: none;
            overflow: hidden;
            white-space: nowrap;
        }
        .now-playing {
            font-size: 1.2rem;
            margin: 0.5rem 0 1rem;
            font-weight: 600;
            text-shadow: 0 0 3px #000;
        }
        .player-container {
            width: 90%;
            max-width: 720px;
            margin: 0 auto 1rem;
            aspect-ratio: 16 / 9;
            position: relative;
            background: #111;
            border: 3px solid gold;
            border-radius: 16px;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            /* Make media player container unresponsive to touch */
            touch-action: none; /* Prevents default touch actions like pan, zoom */
        }
        video, #ytPlayer {
            width: 100%;
            height: 100%;
            /* Make video elements unresponsive to touch on their surface */
            pointer-events: none; /* Prevents all mouse/touch events on the element itself */
            touch-action: none; /* Prevents default touch actions like pan, zoom */
            user-select: none; /* Keep user-select to prevent text selection */
            -webkit-user-select: none;
        }
        #ytPlayer {
            display: none;
        }
        .off-air {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000c;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 10;
            user-select: none;
        }

        /* Speaker button styles */
        #speakerBtn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            user-select: none;
            box-shadow: 0 0 8px gold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            /* Ensure the speaker button itself is clickable */
            pointer-events: auto;
            touch-action: auto;
        }
        #speakerBtn:hover {
            background: rgba(255, 215, 0, 1);
            transform: scale(1.05);
        }
        #speakerIcon {
            width: 24px;
            height: 24px;
            fill: #000;
        }

        /* TV Guide Container styling */
        .tv-guide-container {
            width: 90%;
            max-width: 720px;
            margin: 0 auto 2rem;
            background-color: #1a1a1a; /* Dark background */
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7); /* Stronger gold glow */
            border-radius: 12px;
            padding: 24px;
            user-select: none;
            border: 2px solid gold; /* Subtle gold border */
        }
        .tv-guide-container h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: gold;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px dashed #444; /* Dotted separator */
            padding-bottom: 10px;
            letter-spacing: 1.5px;
            font-family: 'Inter', sans-serif; /* Keep Inter for this header */
        }

        /* TV Guide List (Grid layout for cards) */
        #tvGuideList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid */
            gap: 20px; /* Space between cards */
            max-height: 400px; /* Limit height and make it scrollable */
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
        }
        /* Custom scrollbar for TV guide */
        #tvGuideList::-webkit-scrollbar {
            width: 8px;
        }
        #tvGuideList::-webkit-scrollbar-track {
            background: #2a2a2a; /* Darker track */
            border-radius: 10px;
        }
        #tvGuideList::-webkit-scrollbar-thumb {
            background: #888; /* Gray thumb as in first response */
            border-radius: 10px;
        }
        #tvGuideList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Individual Program Card styling */
        .program-card {
            background-color: #2a2a2a; /* Dark background for cards */
            padding: 16px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5); /* Soft shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            border: 1px solid #333; /* Subtle border */
            text-align: left; /* Align text within card */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space out content vertically */
            font-family: 'Inter', sans-serif; /* Inter for card content */
        }
        .program-card.active {
            background: gold; /* Gold background for active item */
            color: #000; /* Black text on active item */
            font-weight: 700;
            box-shadow: 0 0 20px gold, inset 0 0 10px orange; /* Stronger glow */
            pointer-events: none; /* Active item not clickable */
            transform: scale(1.01); /* Slightly larger */
            border-color: orange;
        }

        .program-card .program-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .program-card .program-time {
            font-size: 0.9em;
            font-weight: 600;
            color: #ccc; /* Lighter color for time */
            background-color: #444; /* Darker badge background */
            padding: 4px 8px;
            border-radius: 6px;
            margin-right: 10px;
            min-width: 85px; /* Ensure consistent width */
            text-align: center;
            font-family: 'Consolas', monospace; /* Keep Consolas for time */
        }
        .program-card.active .program-time {
            color: #333; /* Darker text for active time */
            background-color: rgba(255, 255, 255, 0.6); /* Slightly transparent white for active time badge */
        }
        .program-card .program-status {
            font-size: 0.8em;
            font-weight: 700;
            color: #fff;
            background-color: #6a0dad; /* Purple for 'Next Up' */
            padding: 4px 8px;
            border-radius: 6px;
            text-transform: uppercase;
        }
        .program-card.active .program-status {
             background-color: #1e8449; /* Green for 'Now Playing' */
        }
        .program-card .program-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }
        .program-card.active .program-title {
            color: #000;
        }
        .program-card .program-url {
            font-size: 0.8em;
            color: #aaa;
            opacity: 0.8;
            font-family: 'Consolas', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .program-card.active .program-url {
            color: #333;
        }

        /* Footer styling */
        footer {
            margin-top: auto;
            padding: 2rem 0;
            font-size: 0.85rem;
            color: #aaa;
            user-select: none;
            background-color: #0d0d0d;
            border-top: 1px solid #333;
        }
    </style>
    <!-- External JavaScript libraries -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
    <h1 class="title">MSTV NETWORK</h1>
    <marquee class="golden-scroll" behavior="scroll" direction="left" scrollamount="7" scrolldelay="80">
        ðŸ”¥ Welcome to MSTV | Live Streaming | Entertainment | News | Music ðŸ”¥
    </marquee>

    <div class="now-playing" id="nowPlaying">Now Playing: Loading...</div>
    <div style="font-size: 0.9rem; color: #ccc; margin-bottom: 0.5rem;">
        Melbourne Time: <span id="melNow">loading...</span>
    </div>

    <div class="player-container" id="playerContainer">
        <!-- Added autoplay to HLS video. Muted attribute is initially set to false via JS -->
        <video id="hlsPlayer" playsinline autoplay controlsList="nodownload nofullscreen noremoteplayback"></video>
        <div id="ytPlayer"></div>
        <div class="off-air" id="offAir">ðŸ”Œ Off Air</div>

        <!-- Speaker toggle button -->
        <div id="speakerBtn" title="Toggle mute">
            <svg id="speakerIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 9v6h4l5 5V4L9 9H5z"/>
                <path id="muteCross" d="M16 8l4 4m0-4l-4 4" stroke="#000" stroke-width="2" stroke-linecap="round" style="display:none"/>
            </svg>
        </div>
    </div>

    <!-- TV Guide Section -->
    <div class="tv-guide-container">
        <h2>ðŸ“º Today's Broadcast Schedule</h2>
        <div id="tvGuideList">
            <!-- TV Guide items will be dynamically inserted here by JavaScript -->
        </div>
    </div>

    <footer>
        Â© 2025 MSTV Network. All rights reserved.
    </footer>

    <script>
        // DOM Elements
        const hlsPlayer = document.getElementById('hlsPlayer');
        const ytContainer = document.getElementById('ytPlayer');
        const offAir = document.getElementById('offAir');
        const nowPlaying = document.getElementById('nowPlaying');
        const tvGuideList = document.getElementById('tvGuideList');
        const speakerBtn = document.getElementById('speakerBtn');
        const muteCross = document.getElementById('muteCross');

        // Global state variables
        let currentIndex = 0; // Current video index in the playlist
        let ytPlayer = null; // YouTube player instance
        // Changed default mute state to false to attempt unmuted autoplay
        let isMuted = false; // Global mute state, synchronized with speaker icon and players

        // Define your master sequential playlist here.
        // These videos will play one after another automatically.
        const sources = [
            { title: "Live Stream (MSTV Test)", url: "https://www.youtube.com/watch?v=1b8bBvoIFHY&autoplay=1" }, // Your primary live stream
            { title: "Cafe Jazz Live (YouTube)", url: "https://www.youtube.com/watch?v=Dx5qFachd3A" },
            { title: "Nature Documentary", url: "https://test-streams.mux.dev/test_001/stream.m3u8" },
            { title: "YouTube Music Mix (Relaxing)", url: "https://www.youtube.com/watch?v=k_X1Jb_2S7w&list=RDk_X1Jb_2S7w&start_radio=1" }, // Example YouTube mix
            { title: "World Report", url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8" },
            { title: "Live DJ Set (YouTube)", url: "https://www.youtube.com/watch?v=jfKfPfyJRdk" }, // Another YouTube Live stream example
            { title: "Music Hour (YouTube)", url: "https://www.youtube.com/watch?v=DWcJFNfaw9c" }
        ];

        /**
         * Saves the current playback state (video index, time, and mute status) to localStorage.
         * This ensures the user can resume from where they left off.
         */
        function savePlayerState() {
            try {
                const state = {
                    index: currentIndex,
                    time: getCurrentPlaybackTime(),
                    muted: isMuted
                };
                localStorage.setItem('mstvPlayerState', JSON.stringify(state));
                console.log('Player state saved:', state); // Debugging log
            } catch (e) {
                console.error('Error saving player state to localStorage:', e);
            }
        }

        /**
         * Loads the playback state from localStorage and applies it.
         * If no state is found, it initializes playback from the beginning of the playlist.
         */
        function loadPlayerState() {
            try {
                const savedState = localStorage.getItem('mstvPlayerState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    currentIndex = state.index;
                    // Ensure index is within bounds of the playlist, reset if invalid
                    if (currentIndex < 0 || currentIndex >= sources.length) {
                        currentIndex = 0;
                    }
                    isMuted = state.muted; // Load saved mute state
                    console.log('Player state loaded:', state); // Debugging log
                } else {
                    console.log('No saved state found, starting from beginning, attempting unmuted.');
                    currentIndex = 0;
                    isMuted = false; // Default to unmuted if no state
                }
                // Initial update of mute state for the button icon and players.
                updateMuteState();
                // Play the video with the loaded state.
                playSegment(sources[currentIndex], savedState ? JSON.parse(savedState).time : 0);
            } catch (e) {
                console.error('Error loading player state from localStorage:', e);
                // Fallback to default if there's an error
                currentIndex = 0;
                isMuted = false; // Fallback to unmuted
                updateMuteState();
                playSegment(sources[currentIndex], 0);
            }
        }

        /**
         * Gets the current playback time based on the actively displayed player (HLS or YouTube).
         * @returns {number} The current playback time in seconds.
         */
        function getCurrentPlaybackTime() {
            if (hlsPlayer.style.display === 'block') {
                return hlsPlayer.currentTime;
            } else if (ytPlayer && ytContainer.style.display === 'block' && typeof ytPlayer.getCurrentTime === 'function') {
                return ytPlayer.getCurrentTime();
            }
            return 0;
        }

        /**
         * Plays the next video in the sequential playlist.
         * Wraps around to the beginning if the end of the playlist is reached.
         */
        function playNextVideo() {
            currentIndex = (currentIndex + 1) % sources.length;
            console.log('Playing next video:', sources[currentIndex].title, 'Index:', currentIndex);
            playSegment(sources[currentIndex], 0); // Start next video from beginning
            savePlayerState(); // Save state after changing video
            buildGuide(); // Update TV guide to highlight the new active video
        }

        /**
         * Updates the Melbourne local time display.
         */
        function updateMelbourneTime() {
            const now = luxon.DateTime.now().setZone('Australia/Melbourne');
            document.getElementById('melNow').textContent = now.toFormat('HH:mm:ss');
        }

        /**
         * Builds and updates the TV Guide list based on the sequential playlist.
         * Highlights the currently playing and next up items.
         * This function is purely for display and does not involve click functionality.
         */
        function buildGuide() {
            tvGuideList.innerHTML = ""; // Clear existing guide entries
            sources.forEach((item, i) => {
                const programCard = document.createElement('div');
                programCard.classList.add('program-card');

                let statusText = '';
                let programTimeText = '';

                if (i === currentIndex) {
                    programCard.classList.add("active");
                    statusText = 'NOW PLAYING';
                    programTimeText = 'LIVE'; // Or current time if preferred
                } else if (i === (currentIndex + 1) % sources.length) {
                    statusText = 'NEXT UP';
                    programTimeText = ''; // No specific time for 'Next Up'
                } else {
                    statusText = `#${i + 1}`; // For other items, show sequential number
                    programTimeText = '';
                }

                programCard.innerHTML = `
                    <div class="program-header">
                        ${programTimeText ? `<span class="program-time">${programTimeText}</span>` : ''}
                        <span class="program-status">${statusText}</span>
                    </div>
                    <div class="program-title">${item.title}</div>
                    <div class="program-url">${item.url.length > 50 ? item.url.substring(0, 47) + '...' : item.url}</div>
                `;

                // NO click event listener added here, as per requirement.
                // The TV guide is now purely informational.

                tvGuideList.appendChild(programCard);
            });
            // Scroll to the active item for better user experience
            const activeItem = tvGuideList.querySelector('.program-card.active');
            if (activeItem) {
                // Use a slight delay to ensure layout is stable for scrolling
                setTimeout(() => {
                    activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        /**
         * Displays the "Off Air" message and hides all video players.
         */
        function showOffAir() {
            nowPlaying.textContent = "Now Playing: Off Air";
            offAir.style.display = "flex";
            hlsPlayer.style.display = "none";
            ytContainer.style.display = "none";
            if (ytPlayer) {
                ytPlayer.stopVideo(); // Stop YouTube video if it's active
            }
            hlsPlayer.pause(); // Pause HLS video if it's active
            hlsPlayer.src = ''; // Clear HLS source to ensure it stops.
        }

        /**
         * Plays a specific video segment, managing both HLS and YouTube sources.
         * @param {object} item - The video item containing title and url.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playSegment(item, seekTo = 0) {
            nowPlaying.textContent = `Now Playing: ${item.title}`;
            offAir.style.display = "none"; // Hide off-air message when playing
            console.log(`Attempting to play: ${item.title} from ${seekTo}s`);

            if (item.url.includes("youtube.com") || item.url.includes("youtu.be")) {
                playYouTube(item.url, seekTo);
            } else {
                playHLS(item.url, seekTo);
            }
            buildGuide(); // Always update guide when a new segment plays
        }

        /**
         * Plays an HLS video stream.
         * @param {string} url - The HLS stream URL.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playHLS(url, seekTo) {
            // Stop and hide YouTube player
            if (ytPlayer) {
                ytPlayer.stopVideo();
                // Ensure the YouTube player iframe is truly cleared/hidden to prevent audio bleeding.
                ytContainer.innerHTML = ''; // Clear the inner HTML to remove the iframe
                ytPlayer = null; // Clear the reference to the old player instance
            }
            ytContainer.style.display = "none";
            hlsPlayer.style.display = "block";

            // If an HLS.js instance exists, destroy it before loading a new source.
            if (window.hls) {
                window.hls.destroy();
                window.hls = null; // Clear the reference
            }

            if (hlsPlayer.canPlayType("application/vnd.apple.mpegurl")) {
                hlsPlayer.src = url;
                hlsPlayer.currentTime = seekTo;
                hlsPlayer.muted = isMuted; // Apply global mute state
                hlsPlayer.play().then(() => {
                    console.log("HLS Autoplay successful.");
                }).catch(e => {
                    console.error("HLS Autoplay prevented:", e);
                    // If autoplay fails, ensure it's still muted (browser might enforce) and log
                    hlsPlayer.muted = true;
                    updateMuteState(); // Update UI to reflect actual muted state
                });
            } else if (Hls.isSupported()) {
                window.hls = new Hls();
                window.hls.loadSource(url);
                window.hls.attachMedia(hlsPlayer);
                window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    hlsPlayer.currentTime = seekTo;
                    hlsPlayer.muted = isMuted; // Apply global mute state
                    hlsPlayer.play().then(() => {
                        console.log("HLS Autoplay by HLS.js successful.");
                    }).catch(e => {
                        console.error("HLS Autoplay prevented by HLS.js:", e);
                        hlsPlayer.muted = true;
                        updateMuteState(); // Update UI
                    });
                });
                window.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error("HLS.js error:", data);
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error("Fatal network error, attempting to recover...");
                                window.hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error("Fatal media error, attempting to recover...");
                                window.hls.recoverMediaError();
                                break;
                            default:
                                playNextVideo(); // Play next video on unrecoverable error
                                break;
                        }
                    }
                });
            } else {
                console.error("HLS is not supported in this browser.");
                showOffAir(); // If HLS isn't supported, show off-air
            }
        }

        /**
         * Plays a YouTube video.
         * @param {string} url - The YouTube video URL.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playYouTube(url, seekTo) {
            hlsPlayer.pause();
            hlsPlayer.src = ''; // Clear HLS source to ensure it stops.
            hlsPlayer.style.display = "none";
            ytContainer.style.display = "block";

            // Extract videoId from various YouTube URL formats
            let videoId = '';
            const urlObj = new URL(url);
            if (urlObj.hostname.includes('youtube.com') || urlObj.hostname.includes('youtu.be')) {
                videoId = urlObj.searchParams.get("v");
                if (!videoId && urlObj.pathname.startsWith('/youtu.be/')) {
                    videoId = urlObj.pathname.substring(urlObj.pathname.lastIndexOf('/') + 1);
                }
            }

            if (!videoId) {
                console.error("Could not extract YouTube video ID from URL:", url);
                playNextVideo(); // Play next if video ID cannot be found
                return;
            }

            // Function to apply mute state and ensure playback for YouTube player
            const applyMuteAndPlayYTPlayer = (playerInstance) => {
                if (!playerInstance || typeof playerInstance.unMute !== 'function') {
                    console.warn("applyMuteAndPlayYTPlayer: Player instance not ready or methods missing.");
                    return;
                }

                if (!isMuted) {
                    playerInstance.unMute();
                    playerInstance.setVolume(100); // Set to max volume just to be sure.
                    console.log("YouTube Player: Attempting to unMute and set volume to 100.");
                } else {
                    playerInstance.mute();
                    console.log("YouTube Player: Explicitly muted.");
                }
                playerInstance.playVideo(); // Always attempt to play
                console.log("YouTube Player: Called playVideo().");

                // Verify mute state after a short delay, especially for live streams
                setTimeout(() => {
                    if (playerInstance && typeof playerInstance.isMuted === 'function') {
                        console.log(`YouTube Player Current Mute Status: ${playerInstance.isMuted()}`);
                        console.log(`YouTube Player Current Volume: ${playerInstance.getVolume()}`);
                        // If still muted but shouldn't be (and volume is 0), try again.
                        if (!isMuted && playerInstance.isMuted() && playerInstance.getVolume() === 0) {
                            console.warn("YouTube Player: Still muted despite unMute call. Retrying in 500ms.");
                            setTimeout(() => {
                                if (playerInstance && typeof playerInstance.unMute === 'function') {
                                    playerInstance.unMute();
                                    playerInstance.setVolume(100);
                                    playerInstance.playVideo();
                                    console.log("YouTube Player: Second unMute/play attempt for stubborn case.");
                                }
                            }, 500);
                        }
                    }
                }, 200); // Small delay to allow volume to update
            };


            if (ytPlayer) {
                console.log(`YouTube Player Exists. Loading new video: ${videoId}`);
                // Load new video source
                ytPlayer.loadVideoById({videoId: videoId, startSeconds: seekTo});
                // Apply mute state and play after a very short delay to ensure video data is processing.
                setTimeout(() => applyMuteAndPlayYTPlayer(ytPlayer), 100);

            } else {
                console.log(`Creating new YouTube Player for video: ${videoId}`);
                // Create new player instance
                ytPlayer = new YT.Player("ytPlayer", {
                    height: "100%",
                    width: "100%",
                    videoId: videoId,
                    playerVars: {
                        autoplay: 1,
                        // Set mute to 0 to attempt unmuted autoplay as requested.
                        // Browsers might still force muted autoplay initially without user gesture.
                        mute: 0,
                        start: seekTo,
                        controls: 0,
                        modestbranding: 1,
                        playsinline: 1,
                        disablekb: 1,
                        rel: 0,
                        showinfo: 0
                    },
                    events: {
                        onReady: (e) => {
                            console.log("YouTube player ready.");
                            // On ready, apply the global mute state and start playing.
                            applyMuteAndPlayYTPlayer(e.target);
                        },
                        onStateChange: (e) => {
                            console.log("YouTube Player State Change:", e.data);
                            if (e.data === YT.PlayerState.ENDED) {
                                console.log("YouTube video ended.");
                                playNextVideo(); // Play next video when current one ends
                            } else if (e.data === YT.PlayerState.PLAYING) {
                                console.log("YouTube Player State: PLAYING. Ensuring mute state is correct.");
                                // Re-apply mute state when it starts playing, to catch any browser overrides.
                                applyMuteAndPlayYTPlayer(e.target);
                                // Start saving state periodically while playing YouTube
                                if (!window._ytSaveInterval) {
                                    window._ytSaveInterval = setInterval(savePlayerState, 5000); // Save every 5 seconds
                                }
                            } else {
                                // Clear interval when not playing
                                if (window._ytSaveInterval) {
                                    clearInterval(window._ytSaveInterval);
                                    window._ytSaveInterval = null;
                                }
                            }
                        },
                        onError: (e) => {
                            console.error("YouTube Player Error:", e.data);
                            // On error, try to play the next video in sequence
                            playNextVideo();
                        }
                    }
                });
            }
        }

        /**
         * Toggles the mute state (global `isMuted` variable) and updates the UI (speaker icon)
         * and the actual mute status of the active video player.
         */
        speakerBtn.addEventListener('click', () => {
            isMuted = !isMuted; // Toggle global mute state
            updateMuteState(); // Apply the new state to UI and players
            savePlayerState(); // Save the new mute state immediately
        });

        /**
         * Updates the speaker icon appearance and sets the mute status for the currently active player.
         */
        function updateMuteState() {
            if (isMuted) {
                speakerBtn.title = "Unmute";
                muteCross.style.display = "inline"; // Show mute cross
                hlsPlayer.muted = true; // Mute HLS player
                if (ytPlayer && typeof ytPlayer.mute === 'function') {
                    ytPlayer.mute(); // Mute YouTube player
                    console.log("Speaker button: Muting YouTube player.");
                }
            } else {
                speakerBtn.title = "Mute";
                muteCross.style.display = "none"; // Hide mute cross
                hlsPlayer.muted = false; // Unmute HLS player
                // Attempt to play HLS if it's paused and should be unmuted
                if (hlsPlayer.paused && hlsPlayer.style.display === 'block') {
                    hlsPlayer.play().catch(e => console.error("HLS play on unmute prevented:", e));
                }

                if (ytPlayer && typeof ytPlayer.unMute === 'function') {
                    console.log("Speaker button: Unmuting YouTube player.");
                    ytPlayer.unMute(); // Unmute YouTube player
                    ytPlayer.setVolume(100); // Set YouTube player volume to max

                    // Ensure playback if YouTube player is paused/stopped.
                    if (ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                        ytPlayer.playVideo(); // Attempt to play video
                    }
                }
            }
        }

        // Initialize display and start processes
        window.onload = function() {
            console.log("Window loaded. Initializing...");
            updateMelbourneTime(); // Initial time update
            setInterval(updateMelbourneTime, 1000); // Update time every second
            loadPlayerState(); // Load saved state or start fresh
            buildGuide(); // Initial build of the TV guide

            // Add event listeners for media ending
            hlsPlayer.addEventListener('ended', playNextVideo);

            // Periodically save state for HLS player
            if (!window._hlsSaveInterval) {
                window._hlsSaveInterval = setInterval(savePlayerState, 5000); // Save every 5 seconds
            }

            // Initial update of mute state for the speaker button icon
            updateMuteState();
        };

        // Ensure state is saved when user leaves or closes the page
        window.addEventListener('beforeunload', savePlayerState);

        // Debugging: Log initial mute state
        console.log("Initial global isMuted state:", isMuted);
    </script>
</body>
</html>
