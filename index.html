<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
    <title>MSTV Live</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            text-align: center;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensure footer stays at the bottom */
        }
        .title {
            font-size: 2.5rem;
            font-weight: 900;
            color: gold;
            margin: 1rem 0 0;
            text-shadow: 0 0 15px gold;
        }
        .golden-scroll {
            color: orange;
            font-weight: 700;
            margin-bottom: 1rem;
            user-select: none;
            overflow: hidden;
            white-space: nowrap;
        }
        .now-playing {
            font-size: 1.2rem;
            margin: 0.5rem 0 1rem;
            font-weight: 600;
            text-shadow: 0 0 3px #000;
        }
        .player-container {
            width: 90%;
            max-width: 720px;
            margin: 0 auto 1rem;
            aspect-ratio: 16 / 9;
            position: relative;
            background: #111;
            border: 3px solid gold;
            border-radius: 16px;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            /* Make media player container unresponsive to touch */
            touch-action: none; /* Prevents default touch actions like pan, zoom */
        }
        video, #ytPlayer {
            width: 100%;
            height: 100%;
            /* Make video elements unresponsive to touch on their surface */
            /* pointer-events: none; */ /* Removing this to allow play/pause if needed, but managing via JS */
            touch-action: none; /* Prevents default touch actions like pan, zoom */
            user-select: none; /* Keep user-select to prevent text selection */
            -webkit-user-select: none;
        }
        #ytPlayer {
            display: none;
        }
        .off-air {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000c;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 10;
            user-select: none;
        }

        /* Speaker button styles */
        #speakerBtn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            user-select: none;
            box-shadow: 0 0 8px gold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            /* Ensure the speaker button itself is clickable */
            pointer-events: auto;
            touch-action: auto;
        }
        #speakerBtn:hover {
            background: rgba(255, 215, 0, 1);
            transform: scale(1.05);
        }
        #speakerIcon {
            width: 24px;
            height: 24px;
            fill: #000;
        }

        /* TV Guide Container styling */
        .tv-guide-container {
            width: 90%;
            max-width: 720px;
            margin: 0 auto 2rem;
            background-color: #1a1a1a; /* Dark background */
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7); /* Stronger gold glow */
            border-radius: 12px;
            padding: 24px;
            user-select: none;
            border: 2px solid gold; /* Subtle gold border */
        }
        .tv-guide-container h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: gold;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px dashed #444; /* Dotted separator */
            padding-bottom: 10px;
            letter-spacing: 1.5px;
            font-family: 'Inter', sans-serif; /* Keep Inter for this header */
        }

        /* TV Guide List (Grid layout for cards) */
        #tvGuideList {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid */
            gap: 20px; /* Space between cards */
            max-height: 400px; /* Limit height and make it scrollable */
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
        }
        /* Custom scrollbar for TV guide */
        #tvGuideList::-webkit-scrollbar {
            width: 8px;
        }
        #tvGuideList::-webkit-scrollbar-track {
            background: #2a2a2a; /* Darker track */
            border-radius: 10px;
        }
        #tvGuideList::-webkit-scrollbar-thumb {
            background: #888; /* Gray thumb as in first response */
            border-radius: 10px;
        }
        #tvGuideList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Individual Program Card styling */
        .program-card {
            background-color: #2a2a2a; /* Dark background for cards */
            padding: 16px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5); /* Soft shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            border: 1px solid #333; /* Subtle border */
            text-align: left; /* Align text within card */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space out content vertically */
            font-family: 'Inter', sans-serif; /* Inter for card content */
        }
        .program-card.active {
            background: gold; /* Gold background for active item */
            color: #000; /* Black text on active item */
            font-weight: 700;
            box-shadow: 0 0 20px gold, inset 0 0 10px orange; /* Stronger glow */
            pointer-events: none; /* Active item not clickable */
            transform: scale(1.01); /* Slightly larger */
            border-color: orange;
        }

        .program-card .program-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .program-card .program-time {
            font-size: 0.9em;
            font-weight: 600;
            color: #ccc; /* Lighter color for time */
            background-color: #444; /* Darker badge background */
            padding: 4px 8px;
            border-radius: 6px;
            margin-right: 10px;
            min-width: 85px; /* Ensure consistent width */
            text-align: center;
            font-family: 'Consolas', monospace; /* Keep Consolas for time */
        }
        .program-card.active .program-time {
            color: #333; /* Darker text for active time */
            background-color: rgba(255, 255, 255, 0.6); /* Slightly transparent white for active time badge */
        }
        .program-card .program-status {
            font-size: 0.8em;
            font-weight: 700;
            color: #fff;
            background-color: #6a0dad; /* Purple for 'Next Up' */
            padding: 4px 8px;
            border-radius: 6px;
            text-transform: uppercase;
        }
        .program-card.active .program-status {
             background-color: #1e8449; /* Green for 'Now Playing' */
        }
        .program-card .program-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }
        .program-card.active .program-title {
            color: #000;
        }
        .program-card .program-url {
            font-size: 0.8em;
            color: #aaa;
            opacity: 0.8;
            font-family: 'Consolas', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .program-card.active .program-url {
            color: #333;
        }

        /* Footer styling */
        footer {
            margin-top: auto;
            padding: 2rem 0;
            font-size: 0.85rem;
            color: #aaa;
            user-select: none;
            background-color: #0d0d0d;
            border-top: 1px solid #333;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
    <h1 class="title">MSTV NETWORK</h1>
    <marquee class="golden-scroll" behavior="scroll" direction="left" scrollamount="7" scrolldelay="80">
        ðŸ”¥ Welcome to MSTV | Live Streaming | Entertainment | News | Music ðŸ”¥
    </marquee>

    <div class="now-playing" id="nowPlaying">Now Playing: Loading...</div>
    <div style="font-size: 0.9rem; color: #ccc; margin-bottom: 0.5rem;">
        Melbourne Time: <span id="melNow">loading...</span>
    </div>

    <div class="player-container" id="playerContainer">
        <video id="hlsPlayer" playsinline controlsList="nodownload nofullscreen noremoteplayback"></video>
        <div id="ytPlayer"></div>
        <div class="off-air" id="offAir">ðŸ”Œ Off Air</div>

        <div id="speakerBtn" title="Toggle mute">
            <svg id="speakerIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 9v6h4l5 5V4L9 9H5z"/>
                <path id="muteCross" d="M16 8l4 4m0-4l-4 4" stroke="#000" stroke-width="2" stroke-linecap="round" style="display:none"/>
            </svg>
        </div>
    </div>

    <div class="tv-guide-container">
        <h2>ðŸ“º Today's Broadcast Schedule</h2>
        <div id="tvGuideList">
            </div>
    </div>

    <footer>
        Â© 2025 MSTV Network. All rights reserved.
    </footer>

    <script>
        // DOM Elements
        const hlsPlayer = document.getElementById('hlsPlayer');
        const ytContainer = document.getElementById('ytPlayer');
        const offAir = document.getElementById('offAir');
        const nowPlaying = document.getElementById('nowPlaying');
        const tvGuideList = document.getElementById('tvGuideList');
        const speakerBtn = document.getElementById('speakerBtn');
        const muteCross = document.getElementById('muteCross');

        // Global state variables
        let currentIndex = 0; // Current video index in the playlist
        let ytPlayer = null; // YouTube player instance
        let isMuted = true; // Global mute state, synchronized with speaker icon and players

        // Define your master sequential playlist here.
        // These videos will play one after another automatically.
        const sources = [
            // Added "isLive" flag for explicit identification.
            // You can mark any YouTube video you consider a "live stream" with isLive: true.
            // Replace these with actual YouTube video IDs for live or non-live content.
            // For example: { title: "Live News Channel", url: "https://www.youtube.com/watch?v=your_live_video_id", isLive: true },
            // { title: "Tutorial Video", url: "https://www.youtube.com/watch?v=your_tutorial_video_id", isLive: false },
            { title: "Live Stream (YouTube Demo)", url: "https://www.youtube.com/watch?v=jfKfPfyDMYQ", isLive: true }, // A 24/7 stream example
            { title: "M3U8 Test Stream", url: "https://test-streams.mux.dev/test_001/stream.m3u8", isLive: false },
            { title: "MP4 Video", url: "https://www.learningcontainer.com/wp-content/uploads/2020/05/sample-mp4-file.mp4", isLive: false },
            { title: "Another YouTube Video", url: "https://www.youtube.com/watch?v=dQw4w9WgXcQ", isLive: false }, // Rick Astley!
            { title: "HLS Example Stream", url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8", isLive: false },
            { title: "YouTube Music (Non-Live)", url: "https://www.youtube.com/watch?v=ru0K8uYEZWw", isLive: false }
        ];

        // ---
        // Player State Management
        // ---

        /**
         * Saves the current playback state (video index, time, and mute status) to localStorage.
         * This ensures the user can resume from where they left off.
         */
        function savePlayerState() {
            try {
                const state = {
                    index: currentIndex,
                    time: getCurrentPlaybackTime(),
                    muted: isMuted
                };
                localStorage.setItem('mstvPlayerState', JSON.stringify(state));
                // console.log('Player state saved:', state); // Debugging log
            } catch (e) {
                console.error('Error saving player state to localStorage:', e);
            }
        }

        /**
         * Loads the playback state from localStorage and applies it.
         * If no state is found, it initializes playback from the beginning of the playlist.
         */
        function loadPlayerState() {
            try {
                const savedState = localStorage.getItem('mstvPlayerState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    currentIndex = state.index;
                    // Ensure index is within bounds of the playlist, reset if invalid
                    if (currentIndex < 0 || currentIndex >= sources.length) {
                        currentIndex = 0;
                    }
                    isMuted = state.muted; // Load saved mute state
                    console.log('Player state loaded:', state); // Debugging log
                } else {
                    console.log('No saved state found, starting from beginning, and muted by default.');
                    currentIndex = 0;
                    isMuted = true; // Default to muted if no state found
                }
                // Play the video with the loaded state.
                playSegment(sources[currentIndex], savedState ? JSON.parse(savedState).time : 0);
                // Initial update of mute state for the button icon. This will be updated again by playSegment's logic.
                updateMuteState();
            } catch (e) {
                console.error('Error loading player state from localStorage:', e);
                // Fallback to default if there's an error
                currentIndex = 0;
                isMuted = true;
                playSegment(sources[currentIndex], 0);
                updateMuteState();
            }
        }

        /**
         * Gets the current playback time based on the actively displayed player (HLS or YouTube).
         * @returns {number} The current playback time in seconds.
         */
        function getCurrentPlaybackTime() {
            if (hlsPlayer.style.display === 'block') {
                return hlsPlayer.currentTime;
            } else if (ytPlayer && ytContainer.style.display === 'block' && typeof ytPlayer.getCurrentTime === 'function') {
                // Ensure player is ready before asking for time
                if (ytPlayer.getPlayerState() !== -1) { // -1 means unstarted
                    return ytPlayer.getCurrentTime();
                }
            }
            return 0;
        }

        /**
         * Plays the next video in the sequential playlist.
         * Wraps around to the beginning if the end of the playlist is reached.
         */
        function playNextVideo() {
            currentIndex = (currentIndex + 1) % sources.length;
            console.log('Playing next video:', sources[currentIndex].title, 'Index:', currentIndex);
            playSegment(sources[currentIndex], 0); // Start next video from beginning
            savePlayerState(); // Save state after changing video
            buildGuide(); // Update TV guide to highlight the new active video
        }

        // ---
        // UI Updates
        // ---

        /**
         * Updates the Melbourne local time display.
         */
        function updateMelbourneTime() {
            const now = luxon.DateTime.now().setZone('Australia/Melbourne');
            document.getElementById('melNow').textContent = now.toFormat('HH:mm:ss');
        }

        /**
         * Updates the speaker icon based on the global mute state and applies mute/unmute to players.
         */
        function updateMuteState() {
            if (isMuted) {
                muteCross.style.display = 'block';
                // Mute currently active player
                if (hlsPlayer.style.display === 'block') {
                    hlsPlayer.muted = true;
                } else if (ytPlayer && ytContainer.style.display === 'block' && typeof ytPlayer.mute === 'function') {
                    ytPlayer.mute();
                }
            } else {
                muteCross.style.display = 'none';
                // Unmute currently active player
                if (hlsPlayer.style.display === 'block') {
                    hlsPlayer.muted = false;
                    // Attempt to play if unmuted and paused (HLS can pause automatically when muted)
                    if (hlsPlayer.paused) {
                        hlsPlayer.play().catch(e => console.warn("HLS player play failed on unmute:", e.message));
                    }
                } else if (ytPlayer && ytContainer.style.display === 'block' && typeof ytPlayer.unMute === 'function') {
                    ytPlayer.unMute();
                    ytPlayer.setVolume(100); // Ensure volume is set
                    // Attempt to play if unmuted and paused
                    if (ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                         ytPlayer.playVideo();
                    }
                }
            }
        }

        /**
         * Builds and updates the TV Guide list based on the sequential playlist.
         * Highlights the currently playing and next up items.
         */
        function buildGuide() {
            tvGuideList.innerHTML = ""; // Clear existing guide entries
            sources.forEach((item, i) => {
                const programCard = document.createElement('div');
                programCard.classList.add('program-card');

                let statusText = '';
                let programTimeText = '';

                if (i === currentIndex) {
                    programCard.classList.add("active");
                    statusText = 'NOW PLAYING';
                    programTimeText = 'LIVE';
                } else if (i === (currentIndex + 1) % sources.length) {
                    statusText = 'NEXT UP';
                    programTimeText = '';
                } else {
                    statusText = `#${i + 1}`;
                    programTimeText = '';
                }

                programCard.innerHTML = `
                    <div class="program-header">
                        ${programTimeText ? `<span class="program-time">${programTimeText}</span>` : ''}
                        <span class="program-status">${statusText}</span>
                    </div>
                    <div class="program-title">${item.title}</div>
                    <div class="program-url">${item.url.length > 50 ? item.url.substring(0, 47) + '...' : item.url}</div>
                `;
                tvGuideList.appendChild(programCard);
            });
            // Scroll to the active item for better user experience
            const activeItem = tvGuideList.querySelector('.program-card.active');
            if (activeItem) {
                setTimeout(() => {
                    activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        /**
         * Displays the "Off Air" message and hides all video players.
         */
        function showOffAir() {
            nowPlaying.textContent = "Now Playing: Off Air";
            offAir.style.display = "flex";
            hlsPlayer.style.display = "none";
            ytContainer.style.display = "none";
            if (ytPlayer) {
                ytPlayer.stopVideo(); // Stop YouTube video if it's active
            }
            hlsPlayer.pause(); // Pause HLS video if it's active
            hlsPlayer.src = ''; // Clear HLS source to ensure it stops.
        }

        // ---
        // Video Playback Logic
        // ---

        /**
         * Plays a specific video segment, managing both HLS, MP4 and YouTube sources.
         * @param {object} item - The video item containing title, url, and isLive flag.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playSegment(item, seekTo = 0) {
            nowPlaying.textContent = `Now Playing: ${item.title}`;
            offAir.style.display = "none"; // Hide off-air message when playing
            console.log(`Attempting to play: ${item.title} (isLive: ${item.isLive}) from ${seekTo}s`);

            // Check for YouTube URL pattern
            if (item.url.includes("youtube.com/watch?") || item.url.includes("youtu.be/")) {
                playYouTube(item.url, seekTo, item); // Pass the full item object
            } else if (item.url.endsWith(".m3u8")) {
                playHLS(item.url, seekTo);
            } else if (item.url.endsWith(".mp4")) {
                playMP4(item.url, seekTo);
            } else {
                console.error("Unsupported video format or URL:", item.url);
                showOffAir();
                playNextVideo(); // Try next video on unsupported format
            }
            buildGuide(); // Always update guide when a new segment plays
        }

        /**
         * Plays an HLS video stream.
         * @param {string} url - The HLS stream URL.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playHLS(url, seekTo) {
            // Stop and hide YouTube player
            if (ytPlayer) {
                ytPlayer.stopVideo();
                ytContainer.innerHTML = ''; // Clear the inner HTML to remove the iframe
                ytPlayer = null; // Clear the reference to the old player instance
            }
            ytContainer.style.display = "none";
            hlsPlayer.style.display = "block";

            // If an HLS.js instance exists, destroy it before loading a new source.
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }

            if (hlsPlayer.canPlayType("application/vnd.apple.mpegurl") || hlsPlayer.canPlayType("application/x-mpegURL")) {
                hlsPlayer.src = url;
                hlsPlayer.currentTime = seekTo;
                hlsPlayer.muted = isMuted; // Apply global mute state
                hlsPlayer.load();
                hlsPlayer.play().catch(e => console.warn("HLS native play failed:", e.message)); // Attempt autoplay
            } else if (Hls.isSupported()) {
                window.hls = new Hls();
                window.hls.loadSource(url);
                window.hls.attachMedia(hlsPlayer);
                window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    hlsPlayer.currentTime = seekTo;
                    hlsPlayer.muted = isMuted; // Apply global mute state
                    hlsPlayer.play().catch(e => console.warn("HLS.js play failed:", e.message)); // Attempt autoplay
                });
                window.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error("HLS.js error:", data);
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error("Fatal network error, attempting to recover...");
                                window.hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error("Fatal media error, attempting to recover...");
                                window.hls.recoverMediaError();
                                break;
                            default:
                                playNextVideo(); // Play next video on unrecoverable error
                                break;
                        }
                    }
                });
            } else {
                console.error("HLS is not supported in this browser.");
                showOffAir(); // If HLS isn't supported, show off-air
            }
        }

        /**
         * Plays a standard MP4 video.
         * @param {string} url - The MP4 video URL.
         * @param {number} seekTo - The time in seconds to seek to.
         */
        function playMP4(url, seekTo) {
            // Stop and hide YouTube player
            if (ytPlayer) {
                ytPlayer.stopVideo();
                ytContainer.innerHTML = '';
                ytPlayer = null;
            }
            ytContainer.style.display = "none";
            hlsPlayer.style.display = "block"; // Use the HLS player for MP4 as well

            // Destroy HLS.js instance if it exists
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }

            hlsPlayer.src = url;
            hlsPlayer.currentTime = seekTo;
            hlsPlayer.muted = isMuted; // Apply global mute state
            hlsPlayer.load();
            hlsPlayer.play().catch(e => console.warn("MP4 video play failed:", e.message)); // Attempt autoplay
        }


        /**
         * Plays a YouTube video.
         * @param {string} url - The YouTube video URL.
         * @param {number} seekTo - The time in seconds to seek to.
         * @param {object} item - The full item object to check for live status.
         */
        function playYouTube(url, seekTo, item) {
            hlsPlayer.pause();
            hlsPlayer.src = ''; // Clear HLS source to ensure it stops.
            hlsPlayer.style.display = "none";
            ytContainer.style.display = "block";

            let videoId = '';
            const urlObj = new URL(url);
            if (urlObj.hostname.includes('youtube.com') || urlObj.hostname.includes('youtu.be')) {
                // Extract video ID for standard watch links
                if (urlObj.searchParams.has("v")) {
                    videoId = urlObj.searchParams.get("v");
                }
                // Extract video ID for youtu.be short links
                else if (urlObj.pathname.length > 1) { // e.g., /dQw4w9WgXcQ
                    videoId = urlObj.pathname.substring(1);
                }
            }

            if (!videoId) {
                console.error("Could not extract YouTube video ID from URL:", url);
                playNextVideo(); // Play next if video ID cannot be found
                return;
            }

            // Determine if it's a live stream based on the 'isLive' flag in the sources array
            const isYouTubeLiveStream = item.isLive === true;

            // Define player variables based on whether it's a live stream
            const playerVars = {
                controls: 0,
                modestbranding: 1,
                playsinline: 1,
                disablekb: 1,
                rel: 0,
                showinfo: 0,
                start: seekTo,
                autoplay: isYouTubeLiveStream ? 1 : 0, // Autoplay only for designated live streams
                mute: isYouTubeLiveStream ? 0 : 1    // Unmuted for live streams, muted otherwise (initial state)
            };

            // Function to apply mute/unmute and play state for YouTube player
            const applyMuteAndPlayYTPlayer = (playerInstance) => {
                if (!playerInstance || typeof playerInstance.unMute !== 'function') {
                    console.warn("applyMuteAndPlayYTPlayer: Player instance not ready or methods missing.");
                    return;
                }

                if (isYouTubeLiveStream) {
                    // For live streams, we explicitly try to unmute and play
                    playerInstance.unMute();
                    playerInstance.setVolume(100); // Ensure volume is up
                    playerInstance.playVideo();
                    isMuted = false; // Update global state as we force unmute for live
                    updateMuteState(); // Sync speaker icon
                    console.log("YouTube Live Stream: Attempting to unMute, set volume to 100, and play.");
                } else {
                    // For non-live YouTube videos, apply the global 'isMuted' state
                    if (isMuted) {
                        playerInstance.mute();
                        console.log("YouTube Player (Non-Live): Explicitly muted.");
                    } else {
                        playerInstance.unMute();
                        playerInstance.setVolume(100);
                        console.log("YouTube Player (Non-Live): Explicitly unmuted.");
                    }
                    // Do not call playVideo() here, as non-live streams should only autoplay if browser allows
                    // and are generally expected to be manually played if muted initially.
                }

                // Verify mute state after a short delay
                setTimeout(() => {
                    if (playerInstance && typeof playerInstance.isMuted === 'function') {
                        console.log(`Youtubeer Current Mute Status (verified): ${playerInstance.isMuted()}`);
                        console.log(`Youtubeer Current Volume (verified): ${playerInstance.getVolume()}`);
                    }
                }, 200);
            };

            if (ytPlayer) {
                console.log(`Youtubeer Exists. Loading new video: ${videoId}`);
                ytPlayer.loadVideoById({ videoId: videoId, startSeconds: seekTo });
                // Apply mute and play logic after loading (important for existing player)
                setTimeout(() => applyMuteAndPlayYTPlayer(ytPlayer), 100);
            } else {
                console.log(`Creating new YouTube Player for video: ${videoId}, isLive: ${isYouTubeLiveStream}`);
                ytPlayer = new YT.Player("ytPlayer", {
                    height: "100%",
                    width: "100%",
                    videoId: videoId,
                    playerVars: playerVars,
                    events: {
                        onReady: (e) => {
                            console.log("YouTube player ready.");
                            applyMuteAndPlayYTPlayer(e.target);
                        },
                        onStateChange: (e) => {
                            console.log("YouTube Player State Change:", e.data);
                            if (e.data === YT.PlayerState.ENDED) {
                                console.log("YouTube video ended.");
                                playNextVideo();
                            } else if (e.data === YT.PlayerState.PLAYING) {
                                console.log("YouTube Player State: PLAYING. Ensuring mute state is correct.");
                                // Re-apply mute/play logic when it starts playing, to catch any browser overrides.
                                applyMuteAndPlayYTPlayer(e.target);
                                if (!window._ytSaveInterval) {
                                    window._ytSaveInterval = setInterval(savePlayerState, 5000);
                                }
                            } else {
                                // Clear interval when not playing
                                if (window._ytSaveInterval) {
                                    clearInterval(window._ytSaveInterval);
                                    window._ytSaveInterval = null;
                                }
                            }
                        },
                        onError: (e) => {
                            console.error("YouTube Player Error:", e.data);
                            playNextVideo();
                        }
                    }
                });
            }
        }

        // ---
        // Event Listeners and Initial Setup
        // ---

        // Speaker toggle button
        speakerBtn.addEventListener('click', () => {
            isMuted = !isMuted; // Toggle global mute state
            updateMuteState(); // Apply the new state to UI and players
            savePlayerState(); // Save the new mute state immediately
        });

        // Initialize YouTube Player API when it's ready (global function)
        window.onYouTubeIframeAPIReady = () => {
            console.log("YouTube IFrame API is ready.");
            loadPlayerState(); // Start playback after API is ready
        };

        // For non-YouTube content, listen for 'ended' event to play next
        hlsPlayer.addEventListener('ended', () => {
            console.log("HLS/MP4 video ended.");
            playNextVideo();
        });

        // Update Melbourne time every second
        setInterval(updateMelbourneTime, 1000);

        // Initial setup calls (executed once the script loads)
        updateMelbourneTime(); // Initial time display
        buildGuide(); // Initial guide build

        // If YouTube API is already loaded (can happen if script is deferred or loaded dynamically),
        // call onYouTubeIframeAPIReady directly. Otherwise, it will be called by the API.
        if (typeof YT !== 'undefined' && typeof YT.Player !== 'undefined') {
            window.onYouTubeIframeAPIReady();
        } else {
            console.log("YouTube IFrame API not yet loaded. Waiting for onYouTubeIframeAPIReady...");
        }
    </script>
</body>
</html>
