<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Live TV Channel</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1a1a1a; /* Dark background */
            color: #f0f0f0; /* Light text */
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to give some space above */
            min-height: 100vh;
            flex-direction: column;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .tv-container {
            width: 90%; /* Adjust as needed */
            max-width: 1280px; /* Max width for large screens, e.g., 720p or 1080p aspect */
            border-radius: 10px;
            overflow: hidden; /* Crucial for hiding parts of the scrolling text outside the container */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #2a2a2a;
            margin-top: 20px; /* Add some space from the top */
        }

        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 aspect ratio (height / width * 100) */
            height: 0;
            overflow: hidden;
            background-color: black; /* Background for when video is loading */
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; /* Place it above the video */
            pointer-events: auto; /* It will receive pointer events */
            /* background: rgba(255, 0, 0, 0.1); /* Uncomment for debugging to see the overlay */
        }

        /* NEW: Thumbnail Placeholder Styling */
        .video-thumbnail-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Black background behind thumbnail */
            background-size: contain; /* Scales image to fit without cropping */
            /* Or 'cover' if you prefer the image to fill the space, cropping if necessary */
            background-position: center;
            background-repeat: no-repeat;
            z-index: 12; /* Above video, below overlay/unmute button */
            display: none; /* Hidden by default */
            transition: opacity 0.3s ease; /* Smooth fade in/out */
            opacity: 0;
        }


        /* Custom Unmute Button */
        .unmute-button {
            position: absolute;
            top: 20px; /* Distance from the top */
            right: 20px; /* Distance from the right */

            z-index: 20; /* Place it above the overlay and video */
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            padding: 15px; /* Adjust padding as needed */
            border-radius: 50%; /* Make it circular */
            cursor: pointer;
            font-size: 4.5em; /* ICON SIZE SET TO 4.5em */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, opacity 0.3s ease;
            opacity: 1; /* Default visible state */
        }

        .unmute-button:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .unmute-button .mute-icon { display: none; }
        .unmute-button.muted .mute-icon { display: inline-block; }
        .unmute-button.muted .unmute-icon { display: none; }
        .unmute-button:not(.muted) .mute-icon { display: none; }
        .unmute-button:not(.muted) .unmute-icon { display: inline-block; }

        /* Scrolling Text Container */
        .scrolling-text-container {
            position: absolute; /* Position relative to .video-container */
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px; /* Height of the ticker */
            background-color: red; /* Red background */
            overflow: hidden; /* Hide text outside this band */
            z-index: 15; /* Above video, below unmute button */
            display: flex;
            align-items: center; /* Vertically center the text */
            white-space: nowrap; /* Prevent text from wrapping */
            box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.3); /* Subtle shadow above ticker */
        }

        .scrolling-text {
            color: white; /* White text */
            font-size: 1.2em; /* Adjust font size */
            font-weight: bold;
            padding-left: 100%; /* Start text off-screen to the right */
            animation: scroll-left 40s linear infinite; /* Animation duration and loop */
        }

        /* Keyframe animation for scrolling */
        @keyframes scroll-left {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); } /* Scrolls its own width left */
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .tv-container {
                width: 95%;
            }

            .unmute-button {
                top: 10px;
                right: 10px;
                padding: 10px;
                font-size: 3.0em; /* Adjusted for smaller screens */
            }

            .scrolling-text-container {
                height: 30px; /* Smaller height on smaller screens */
            }

            .scrolling-text {
                font-size: 1em;
                animation-duration: 30s; /* Faster scroll on smaller screens */
            }
        }

        @media (max-width: 480px) {
            .tv-container {
                width: 100%;
                border-radius: 0;
            }
            .unmute-button {
                top: 5px;
                right: 5px;
                padding: 8px;
                font-size: 2.0em; /* Adjusted for very small screens */
            }

            .scrolling-text-container {
                height: 25px;
            }

            .scrolling-text {
                font-size: 0.9em;
                animation-duration: 25s;
            }
        }
    </style>
</head>
<body>

    <div class="tv-container">
        <div class="video-container">
            <div id="player"></div>
            <div class="video-overlay"></div>
            <div class="video-thumbnail-placeholder" id="videoThumbnail"></div> 
            <button id="unmuteButton" class="unmute-button muted">
                <span class="mute-icon">ðŸ”‡</span>
                <span class="unmute-icon">ðŸ”Š</span>
            </button>

            <div class="scrolling-text-container">
                <div class="scrolling-text" id="newsTicker">
                    Welcome to MSTV NETWORK Live TV Channel! Tune in 24/7 for great content Music, Mastii, Drama, Comedy, Movies all in one, Stay tuned...</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.33/moment-timezone-with-data.min.js"></script>

    <script>
        // Helper function to parse various YouTube URLs/IDs
        function parseYouTubeLink(link) {
            const videoRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
            const playlistRegex = /(?:youtube\.com\/(?:playlist\?list=|embed\/videoseries\?list=))([a-zA-Z0-9_-]+)/;

            let match;

            match = link.match(playlistRegex);
            if (match && match[1]) return { type: 'playlist', id: match[1] };

            match = link.match(videoRegex);
            if (match && match[1]) return { type: 'video', id: match[1] };

            if (link.length === 11 && /^[a-zA-Z0-9_-]+$/.test(link)) {
                return { type: 'video', id: link };
            }

            console.warn(`Unrecognized YouTube link format: ${link}`);
            return null;
        }

        // --- GLOBAL STATE VARIABLES ---
        const LAST_PLAYED_KEY = 'lastPlayedVideo';
        let player;
        let saveInterval; // For saving last played position
        let checkScheduleInterval; // For checking schedule changes
        let currentScheduledProgram = null; // Stores the currently playing schedule block
        let currentVideoIndexInProgram = 0; // Index within the current program's video_urls
        let scheduleData = null; // Stores the loaded schedule from JSON

        const unmuteButton = document.getElementById('unmuteButton');
        const newsTicker = document.getElementById('newsTicker');
        const videoThumbnail = document.getElementById('videoThumbnail');

        // Helper function to get YouTube thumbnail URL
        function getThumbnailUrl(videoId) {
            return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
        }

        // Function to display the thumbnail
        function displayThumbnail(videoId) {
            if (!videoId) {
                console.warn("No video ID provided for thumbnail.");
                videoThumbnail.style.opacity = '0';
                videoThumbnail.style.display = 'none';
                return;
            }
            videoThumbnail.style.backgroundImage = `url('${getThumbnailUrl(videoId)}')`;
            videoThumbnail.style.display = 'block';
            // Trigger reflow for transition to work
            videoThumbnail.offsetHeight;
            videoThumbnail.style.opacity = '1';
        }

        // Function to hide the thumbnail
        function hideThumbnail() {
            videoThumbnail.style.opacity = '0';
            // Hide only after transition
            setTimeout(() => {
                videoThumbnail.style.display = 'none';
                videoThumbnail.style.backgroundImage = 'none'; // Clear image
            }, 300); // Match CSS transition duration
        }

        // --- NEW: FETCH SCHEDULE DATA ---
        async function fetchSchedule() {
            try {
                const response = await fetch('schedule.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                scheduleData = await response.json();
                console.log('Schedule loaded:', scheduleData);

                // Sort the schedule once after loading for reliable lookup in getScheduledVideo
                scheduleData.schedule.sort((a, b) => {
                    const timeA = moment(a.start_time, 'HH:mm');
                    const timeB = moment(b.start_time, 'HH:mm');
                    return timeA.diff(timeB);
                });

                // Initialize player only after schedule is loaded
                onYouTubeIframeAPIReady();
            } catch (error) {
                console.error('Could not load schedule.json:', error);
                alert('Failed to load TV schedule. Please ensure schedule.json exists and is valid. Check console for details.');
            }
        }

        // --- MODIFIED: DETERMINE CURRENTLY SCHEDULED VIDEO FOR A 24/7 LOOP ---
        function getScheduledVideo() {
            if (!scheduleData || !scheduleData.schedule || scheduleData.schedule.length === 0) {
                console.warn("No schedule data available.");
                return null;
            }

            const now = moment().tz(scheduleData.timezone);
            const sortedSchedule = scheduleData.schedule; // Already sorted in fetchSchedule

            let foundProgram = null;
            let foundProgramOriginalIndex = -1;
            let nextProgramForTicker = null;

            // Step 1: Find the program that 'now' is explicitly within
            for (let i = 0; i < sortedSchedule.length; i++) {
                const program = sortedSchedule[i];
                let startTime = moment.tz(`${now.format('YYYY-MM-DD')} ${program.start_time}`, 'YYYY-MM-DD HH:mm', scheduleData.timezone);
                let endTime = moment.tz(`${now.format('YYYY-MM-DD')} ${program.end_time}`, 'YYYY-MM-DD HH:mm', scheduleData.timezone);

                // Handle overnight programs (e.g., 23:00 - 01:00)
                if (endTime.isBefore(startTime)) {
                    endTime.add(1, 'day');
                }

                if (now.isBetween(startTime, endTime, null, '[)')) {
                    foundProgram = program;
                    // Find original index for localStorage saving
                    foundProgramOriginalIndex = scheduleData.schedule.findIndex(p =>
                        p.start_time === program.start_time &&
                        p.end_time === program.end_time &&
                        JSON.stringify(p.video_urls) === JSON.stringify(program.video_urls)
                    );
                    // Determine the next program for the ticker (wrap around if last program)
                    nextProgramForTicker = sortedSchedule[(i + 1) % sortedSchedule.length];
                    break;
                }
            }

            // Step 2: If no program found (meaning 'now' is in a schedule gap or after last program/before first)
            // Determine the program that should be playing in a continuous 24/7 loop.
            if (!foundProgram) {
                const nowSecondsSinceMidnight = now.diff(now.clone().startOf('day'), 'seconds');

                // Iterate through the sorted schedule to find the *last* program that started *before or at* now
                // (or the one that wraps into now).
                // This will be the "active" program for any gaps
                for (let i = sortedSchedule.length - 1; i >= 0; i--) {
                    const program = sortedSchedule[i];
                    const programStartSeconds = moment(program.start_time, 'HH:mm').diff(moment(program.start_time, 'HH:mm').startOf('day'), 'seconds');
                    let programEndSeconds = moment(program.end_time, 'HH:mm').diff(moment(program.end_time, 'HH:mm').startOf('day'), 'seconds');

                    // Adjust end time for overnight programs to conceptualize a 24hr cycle
                    if (programEndSeconds < programStartSeconds) {
                        programEndSeconds += 24 * 3600;
                    }

                    // For the looping logic, if current time is before the start of the first program (e.g., 03:00 and first is 08:00)
                    // then we are effectively in the end part of the last program from the previous day's cycle.
                    let effectiveNowSeconds = nowSecondsSinceMidnight;
                    if (nowSecondsSinceMidnight < programStartSeconds && programStartSeconds > programEndSeconds - 24 * 3600) {
                        effectiveNowSeconds += 24 * 3600; // Treat early morning as 'next day' for overnight comparison
                    }

                    if (effectiveNowSeconds >= programStartSeconds && effectiveNowSeconds < programEndSeconds) {
                         foundProgram = program;
                         foundProgramOriginalIndex = scheduleData.schedule.findIndex(p =>
                            p.start_time === program.start_time &&
                            p.end_time === program.end_time &&
                            JSON.stringify(p.video_urls) === JSON.stringify(program.video_urls)
                        );
                         // Determine next program for ticker
                         nextProgramForTicker = sortedSchedule[(i + 1) % sortedSchedule.length];
                         break;
                    }
                }

                // Fallback: If no program was found by direct match or loop logic (e.g., very sparse schedule)
                // Default to the first program of the day
                if (!foundProgram && sortedSchedule.length > 0) {
                    foundProgram = sortedSchedule[0];
                    foundProgramOriginalIndex = scheduleData.schedule.findIndex(p =>
                        p.start_time === foundProgram.start_time &&
                        p.end_time === foundProgram.end_time &&
                        JSON.stringify(p.video_urls) === JSON.stringify(foundProgram.video_urls)
                    );
                    nextProgramForTicker = sortedSchedule[1 % sortedSchedule.length]; // Second program or first again if only one
                }
            }


            if (foundProgram) {
                return {
                    program: foundProgram,
                    programIndex: foundProgramOriginalIndex,
                    nextProgram: nextProgramForTicker // Pass the next program info for ticker
                };
            }
            console.warn("Could not determine any program to play for continuous loop.");
            return null; // Should ideally not happen if schedule covers 24 hours or has sensible loop logic
        }

        // --- MODIFIED: LOAD VIDEO BASED ON SCHEDULE ---
        function loadScheduledVideo() {
            const scheduled = getScheduledVideo();

            // The 'if (!scheduled)' block for "No program scheduled" is removed
            // because `getScheduledVideo` is now designed to always return a program
            // for a continuous 24/7 loop. If `getScheduledVideo` *does* return null here,
            // it indicates a serious issue (e.g., empty scheduleData).
            if (!scheduled) {
                console.error("Failed to determine scheduled program. Schedule might be empty or invalid.");
                // Optionally, play a static "Error" screen video
                // player.loadVideoById('ERROR_VIDEO_ID');
                newsTicker.textContent = "Error: Schedule not available. Please try again later.";
                return;
            }

            const program = scheduled.program;
            const programIndex = scheduled.programIndex;
            const nextProgram = scheduled.nextProgram; // Get the next program for the ticker

            // Update news ticker with current program info
            newsTicker.textContent = `Now Playing: ${program.content_type} | Next: ${nextProgram ? nextProgram.content_type + ' at ' + nextProgram.start_time : 'End of Cycle'} (${scheduleData.timezone})`;

            // Check if we are already playing this program AND the video list is the same
            if (currentScheduledProgram &&
                currentScheduledProgram.start_time === program.start_time &&
                currentScheduledProgram.end_time === program.end_time &&
                JSON.stringify(currentScheduledProgram.video_urls) === JSON.stringify(program.video_urls)) {
                // We are still in the same program block with the same video content.
                return;
            }

            // A new program has started or we just loaded the page or the program content changed
            console.log(`Switching to new program: ${program.content_type}`);
            currentScheduledProgram = program;
            currentVideoIndexInProgram = 0; // Start from the first video of the new program

            // Try to resume from localStorage if it's the *same* program as last time
            const lastPlayed = JSON.parse(localStorage.getItem(LAST_PLAYED_KEY));
            let startTime = 0;

            if (lastPlayed && lastPlayed.programIndex === programIndex) {
                 const lastPlayedVideoId = lastPlayed.videoId;
                const currentProgramExpectedVideoId = program.video_urls[lastPlayed.videoIndexInProgram];

                if (lastPlayedVideoId === currentProgramExpectedVideoId) {
                    startTime = lastPlayed.time;
                    currentVideoIndexInProgram = lastPlayed.videoIndexInProgram;
                    console.log(`Resuming program "${program.content_type}" at video index ${currentVideoIndexInProgram} from ${startTime}s.`);
                } else {
                    console.log(`Last played video (${lastPlayedVideoId}) does not match current program's expected video (${currentProgramExpectedVideoId}). Starting from beginning of program.`);
                }
            } else {
                console.log(`Starting program "${program.content_type}" from beginning.`);
            }

            const videoIdToPlay = program.video_urls[currentVideoIndexInProgram];
            const parsedVideo = parseYouTubeLink(videoIdToPlay);

            if (parsedVideo && parsedVideo.type === 'video') {
                console.log(`Loading scheduled video: ${parsedVideo.id} at ${startTime}s`);
                displayThumbnail(parsedVideo.id);
                player.loadVideoById(parsedVideo.id, startTime);
                player.unMute();
                unmuteButton.classList.remove('muted');
            } else {
                console.error(`Invalid video ID in schedule for program ${program.content_type}: ${videoIdToPlay}. Skipping.`);
                currentVideoIndexInProgram++;
                if (currentVideoIndexInProgram < program.video_urls.length) {
                    loadScheduledVideo(); // Recursively try the next video in the same program
                } else {
                    console.error(`All videos in program "${program.content_type}" are invalid or program has no videos. Trying to load the first video of the current program from the beginning as a fallback.`);
                    // Fallback to first video of current program, starting at 0 if all failed
                    currentVideoIndexInProgram = 0;
                    const fallbackVideoId = program.video_urls[currentVideoIndexInProgram];
                    const parsedFallback = parseYouTubeLink(fallbackVideoId);
                    if (parsedFallback && parsedFallback.type === 'video') {
                        displayThumbnail(parsedFallback.id);
                        player.loadVideoById(parsedFallback.id, 0);
                    } else {
                        console.error("Critical: Cannot find any valid video to play for this program.");
                        // If all fails, you might want to load a "channel error" video
                    }
                }
            }
        }

        // --- PLAYER API FUNCTIONS ---

        // This function creates an <iframe> (and YouTube player)
        // after the API code downloads.
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '390',
                width: '640',
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'disablekb': 1,
                    'autohide': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'iv_load_policy': 3
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        // The API will call this function when the video player is ready.
        function onPlayerReady(event) {
            loadScheduledVideo(); // Initial load of the scheduled video

            player.mute();
            unmuteButton.classList.add('muted');

            // Save current position every 5 seconds
            saveInterval = setInterval(() => {
                if (player && player.getCurrentTime && currentScheduledProgram) {
                    const programIdx = scheduleData.schedule.findIndex(p =>
                        p.start_time === currentScheduledProgram.start_time &&
                        p.end_time === currentScheduledProgram.end_time &&
                        JSON.stringify(p.video_urls) === JSON.stringify(currentScheduledProgram.video_urls)
                    );

                    if (programIdx !== -1 && currentVideoIndexInProgram < currentScheduledProgram.video_urls.length) {
                        localStorage.setItem(LAST_PLAYED_KEY, JSON.stringify({
                            programIndex: programIdx,
                            videoIndexInProgram: currentVideoIndexInProgram,
                            videoId: currentScheduledProgram.video_urls[currentVideoIndexInProgram],
                            time: player.getCurrentTime()
                        }));
                    }
                }
            }, 5000);

            // Check schedule every minute to see if a new program should start
            checkScheduleInterval = setInterval(loadScheduledVideo, 60 * 1000); // Every 1 minute
        }

        // The API calls this function when the player's state changes.
        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                console.log(`Current video naturally ended. Checking next video in program.`);
                currentVideoIndexInProgram++;
                if (currentScheduledProgram && currentVideoIndexInProgram < currentScheduledProgram.video_urls.length) {
                    // Play next video in the current program
                    const nextVideoId = currentScheduledProgram.video_urls[currentVideoIndexInProgram];
                    const parsedNext = parseYouTubeLink(nextVideoId);
                    if (parsedNext && parsedNext.type === 'video') {
                        displayThumbnail(parsedNext.id);
                        player.loadVideoById(parsedNext.id, 0); // Start next video from beginning
                    } else {
                        console.error(`Invalid video ID for next video in program: ${nextVideoId}. Skipping.`);
                        onPlayerError({data: -1}); // Simulate an error to skip this video
                    }
                } else {
                    // All videos in the current program have played.
                    // Now, we need to check if we are still within the same scheduled program slot.
                    // If yes, loop the videos for the current program.
                    // If no, loadScheduledVideo() will pick up the next program via the checkScheduleInterval
                    // or if it's called directly by the logic below.
                    currentVideoIndexInProgram = 0; // Reset to loop to the first video of the current program

                    // Re-check the schedule immediately to see if a new program has started
                    // This handles cases where the program videos finish exactly at the program slot end time.
                    const scheduled = getScheduledVideo(); // Get what *should* be playing now

                    if (scheduled && scheduled.program.start_time === currentScheduledProgram.start_time &&
                        scheduled.program.end_time === currentScheduledProgram.end_time) {
                        // Still in the same program slot, so loop the current program's videos
                        console.log("End of program's video list, still within same program slot. Looping videos.");
                        const nextVideoId = currentScheduledProgram.video_urls[currentVideoIndexInProgram]; // This will be the first video again
                        const parsedNext = parseYouTubeLink(nextVideoId);
                         if (parsedNext && parsedNext.type === 'video') {
                            displayThumbnail(parsedNext.id);
                            player.loadVideoById(parsedNext.id, 0);
                        } else {
                            console.error(`Invalid video ID for looping video in program: ${nextVideoId}. Skipping.`);
                            onPlayerError({data: -1}); // Simulate an error to skip this video
                        }
                    } else {
                        // A new program slot is now active (or should be). Let loadScheduledVideo handle it.
                        console.log("Program slot ended or new program detected. Switching program.");
                        loadScheduledVideo();
                    }
                }
            } else if (event.data === YT.PlayerState.PLAYING) {
                hideThumbnail();
            } else if (event.data === YT.PlayerState.BUFFERING) {
                const currentVideoId = currentScheduledProgram && currentScheduledProgram.video_urls[currentVideoIndexInProgram] ? currentScheduledProgram.video_urls[currentVideoIndexInProgram] : null;
                const parsedCurrent = parseYouTubeLink(currentVideoId);
                displayThumbnail(parsedCurrent ? parsedCurrent.id : null);
            }
        }

        // Handle player errors (e.g., video not found, private video, playback issue)
        function onPlayerError(event) {
            console.error('YouTube Player Error:', event.data, 'Attempting to skip to next item in program.');
            currentVideoIndexInProgram++;
            if (currentScheduledProgram && currentVideoIndexInProgram < currentScheduledProgram.video_urls.length) {
                const nextVideoId = currentScheduledProgram.video_urls[currentVideoIndexInProgram];
                const parsedNext = parseYouTubeLink(nextVideoId);
                if (parsedNext && parsedNext.type === 'video') {
                    displayThumbnail(parsedNext.id);
                    player.loadVideoById(parsedNext.id, 0);
                } else {
                    console.error(`Invalid video ID for next video after error: ${nextVideoId}. Skipping.`);
                    loadScheduledVideo(); // Re-evaluate schedule
                }
            } else {
                console.error("All videos in current program failed or no more videos. Checking for next scheduled program or looping program.");
                // If all videos in program fail, or no more videos in program, re-evaluate schedule
                // This ensures we jump to the next *scheduled* content or loop to the start of current if still valid.
                loadScheduledVideo();
            }
        }

        // Unmute button functionality
        unmuteButton.addEventListener('click', () => {
            if (player && player.isMuted()) {
                player.unMute();
                unmuteButton.classList.remove('muted');
            } else if (player) {
                player.mute();
                unmuteButton.classList.add('muted');
            }
        });

        // Load the IFrame Player API asynchronously.
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api"; // The OFFICIAL YouTube API URL
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // Clear intervals and timeouts when the page is about to be unloaded
        window.addEventListener('beforeunload', () => {
            clearInterval(saveInterval);
            clearInterval(checkScheduleInterval);
        });

        // --- START THE PROCESS: FETCH THE SCHEDULE FIRST ---
        fetchSchedule();
    </script>

</body>
</html>
